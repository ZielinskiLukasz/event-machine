[{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1","title":"About Event Machine","content":"prooph software Event Machine takes away all the boring, time consuming parts of event sourcing to speed up development of event sourced applications and increase the fun. It can be used for prototypes as well as full featured applications."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1","title":"Microservices","content":"Event Machine emphasises a Microservices architecture where individual services are kept relatively small and autonomous. When dividing application logic into multiple independent services it is mandatory to have tools in place to orchestrate and manage them. On the infrastructure level there are many excellent tools available but this is not enough. If you have a business process that involves 3 different services you need a sane way to visualize and control that process as a whole. With the built-in message flow analyzer Event Machine is capable of providing such a visualization and monitoring tool."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-2","title":"Origin","content":"Event Machine was originally designed as a \"workshop framework\" for CQRS and Event Sourcing and is inspired by the Dreyfus model."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-2-1","title":"Beginner friendly","content":" The Dreyfus model distinguishes five levels of competence, from novice to mastery. At the absolute beginner level people execute tasks based on \u00e2\u0080\u009crigid adherence to taught rules or plans\u00e2\u0080\u009d. Beginners need recipes. They don\u00e2\u0080\u0099t need a list of parts, or a dozen different ways to do the same thing. Instead what works are step by step instructions that they can internalize. As they practice them over time they learn the reasoning behind them, and learn to deviate from them and improvise, but they first need to feel like they\u00e2\u0080\u0099re doing something. (source: https:\/\/lambdaisland.com\/blog\/25-05-2017-simple-and-happy-is-clojure-dying-and-what-has-ruby-got-to-do-with-it)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-2-2","title":"Rapid Application Development","content":"It turned out that Event Machine is not only a very good CQRS and Event Sourcing learning framework but that the same concept can be used for rapid application development (RAD). RAD frameworks focus on developer happiness and coding speed. Both can be achieved by using conventions, which allows the framework to do a lot of work \"under the hood\" so that developers can focus on the important part: developing the application.Having said this, Event Machine can be compared with frameworks like Ruby on Rails or Laravel, but it also has a unique selling point. Instead of working with a CRUD based approach, Event Machine uses CQRS and Event Sourcing, leveraging prooph\/components under the hood. This enables interesting scenarios like starting a project with a lean and rapid development approach and switch to an enterprise approach later. With Event Machine you get separation of concerns from day one. You also get separated write and read models which can be scaled independent of each other. Finally, you get a full history of all state changes, so it is not only cheap to develop an application with Event Machine but it's also cheap to maintain that application in production."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-3","title":"Powered By","content":"Event Machine is maintained by the prooph software team. Prooph software offers commercial support and workshops for Event Machine as well as for the prooph components.If you are interested please get in touch"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-1","title":"Pros","content":" Default set up based on the rich features provided by prooph components Ready-to-use skeleton Less code to write Guided event sourcing extension points to inject custom logic Audit log from day one (no data loss) Replay functionality Projections based on domain events PSR friendly http message box OpenAPI v3 Swagger integration Message flow analyzer (work in progress) Event store HTTP API (work in progress) "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-2","title":"Cons","content":" Opinionated approach Not based on common OOP patterns Not suitable for monolithic architectures "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-3","title":"Conclusion","content":"Reading through the pros and cons you may ask yourself when and why you should use Event Machine. Here is a list of hints that may help you make a decision. Also try the tutorial and build a prototype with Event Machine! (If you are interested, you can contact us for a guided workshop):"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-3-1","title":"You may want to use Event Machine if:","content":" You want to establish a service-oriented architecture rather than building a monolithic system Your project is in an early stage and you need to try out different ideas or deliver features very fast You want to automate business processes You have to develop a workflow-oriented service You're new to the concepts of CQRS and Event Sourcing and want to learn them You want to try CQRS and Event Sourcing in a side project without spending too much time with the theory Note: Even if Event Machine is opinionated it is designed to support loose coupling between different parts of an application. This means that if you start a project using Event Machine but it gets in your way later you can get rid of it step by step (continuous refactoring)."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1","title":"Introduction","content":"Event Machine is a rapid application development (RAD) framework so let us jump directly into the practical part of the tutorial. Event Machine basic concepts will be explained throughout the tutorial. Once finished, you should be able to start with your own project. The API docs will help you along the way."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-1","title":"Workshops And Commercial Support","content":"Our team can help you to take the first steps and work out a solid foundation for your project based on the power and speed offered by Event Machine. If you're interested in workshops or commercial support, get in touch."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-2","title":"Tutorial Domain","content":"We will build a backend for a small application where you can register buildings and then check in and check out users in the buildings. The backend will expose a messagebox endpoint that excepts commands and queries. Each time a user is checked in or checked out we get a notification via a websocket connection.Credits: The tutorial domain is the same as the one used by Marco Pivetta in his CQRS and Event Sourcing Workshops."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3","title":"Application set up","content":"Please make sure you have Docker and Docker Compose installed.Note: Docker is THE ONLY supported set up at the moment. If you don't want to install docker you need PHP 7.1+ and Postgres 9.4+."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-1","title":"Clone Event Machine Skeleton","content":"Change into your working directory and use composer to create a new project based on the event machine skeleton using prooph-em-buildings as project name.$ docker run --rm -it -v $(pwd):\/app prooph\/composer:7.1 create-project proophsoftware\/event-machine-skeleton prooph-em-buildings Change into the newly created project dir prooph-em-buildings, start the docker containers and run the set up script for the event store.$ cd prooph-em-buildings $ sudo chown -R $(id -u -n):$(id -g -n) . $ docker-compose up -d $ docker-compose run php php scripts\/create_event_stream.php The last command should output done. otherwise it will throw an exception."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-1","title":"Database","content":"Verify database set up by connecting to the Postgres database using:host: localhost port: 5432 dbname: event_machine user: postgres pwd: Note: Credentials are defined in app.env and can be changed there.You should see three tables: event_streams, projections and _&lt;sha1&gt;. The latter is a table created by prooph\/event-store. It will contain all domain events."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-2","title":"Webserver","content":"Head over to http:\/\/localhost:8080 to check if the containers are up and running. You should see a \"It works\" message."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-3","title":"Swagger UI","content":"By default Event Machine exposes commands (we will learn more about them in a minute), events and queries via a message box endpoint. We can use Swagger UI to interact with the backend.The Event Machine skeleton ships with a ready to use Swagger UI. Open http:\/\/localhost:8080\/swagger\/index.html in your browser and try the built-in HealthCheck query.You should get a JSON response similar to that one:{ \"system\": true } If everything works correctly we are ready to implement our first use case: Add a buildingNote: If something is not working as expected (now or later in the tutorial) please check the trouble shooting section of the event-machine-skeleton README first."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2","title":"Part I - Add A Building","content":"We're going to add the first action to our buildings application. In a CQRS system, such as Event Machine, operations and processes are triggered by messages. Those messages can have three different types and define the API of the application. In the first part of the tutorial we learn the first message type: command."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-1","title":"API","content":"The Event Machine skeleton includes an API folder (src\/Api) that contains a predefined set of EventMachineDescription classes. We will look at these descriptions step by step and start with src\/Api\/Command.php:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Command implements EventMachineDescription { \/** * Define command names using constants * * @example * * const REGISTER_USER = 'RegisterUser'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Describe commands of the service and corresponding payload schema (used for input validation) } } The Command description is used to group all commands of our application into one file and add semantic meaning to our code. Replace the comment with a real constant const ADD_BUILDING = 'AddBuilding'; and register the command in the describe method.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } Event Machine uses JSON Schema to describe messages. The advantage of JSON schema is that we can configure validation rules for our messages. Whenever Event Machine receives a message (command, event or query) it uses the defined JSON Schema for that message to validate the input. We configure it once and Event Machine takes care of the rest.Note: The skeleton defines the namespace App in composer.json and maps it to the src directory. You can change that for your own project, but you need to change the namespaces of the classes\/interfaces shipped with the skeleton which are located in the src directory (just a few helpers)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-2","title":"Descriptions","content":"Event Machine Descriptions are very important. They are called at \"compile time\" and used to configure Event Machine. Later in the tutorial we learn more about using Event Machine in production. In production mode the descriptions are only called once and cached to speed up bootstrapping."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-3","title":"Swagger Integration","content":"Switch to the Swagger UI and reload the schema (press explore button). Swagger UI should show a new command called AddBuilding in the commands section.Click on the \"Try it out\" button and execute the AddBuilding command with the this request body:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } { \"error\": { \"message\": \"CommandBus was not able to identify a CommandHandler for command AddBuilding\", \"details\": \"...\" } } Our command cannot be handled because a command handler is missing. In Event Machine commands can be routed directly to Aggregates. In part II of the the tutorial you'll learn more about pure aggregates.Sum up: Event Machine Descriptions allow you to easily describe the API of your application using messages. The messages get a unique name and their payload is described with JSON Schema which allow us to add validation rules. The messages and their schema are translated to an OpenAPI v3 Schema and we can use Swagger UI to interact with the backend service."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3","title":"Part II - The Building Aggregate","content":"In Event Machine we can take a short cut and skip command handlers. This is possible because Aggregates in Event Machine are stateless and pure. This means that they don't have internal state and also no dependencies.Simply put: they are just functionsEvent Machine can take over the boilerplate and we, as developers, can focus on the business logic. I'll explain in greater detail later, but first we want to see a pure aggregate function in action.Note: If you've worked with a CQRS framework before it is maybe confusing because normally a command is handled by a command handler (comparable to an application service that handles a domain action) and the command handler would load a business entity or \"DDD\" aggregate from a repository. We still use the aggregate concept but make use of a functional programming approach. It keeps the domain model lean and testable and allows some nice optimizations for a RAD infrastructure.Let's add the first aggregate called Building in a new Model folder:&lt;?php declare(strict_types=1); namespace App\\Model; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { \/\/yield domain events } } As you can see the Building class uses static methods. It does not extend from a base class and has no dependencies. We could also use plain PHP functions instead but unfortunately PHP does not provide function autoloading (yet), so we stick to static methods and group all methods of an aggregate in a class.Building::add() receives AddBuilding messages (of type command) and should perform the business logic needed to add a new building to our application. But instead of adding a new building directly we're ask to yield a domain event."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-1","title":"Domain Events","content":"Domain events are the second message type used by Event Machine. The domain model is event sourced, meaning it records all state changes in a series of domain events. These domain events are yielded by aggregate methods and stored in an event store managed by Event Machine. The series of events can then be used to calculate the current state of an aggregate. We will see that in action in a later part of the tutorial and get a better understanding of the technique when we add more use cases to the application.For now let's add the first domain event in src\/Api\/Event:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } It looks similar to the AddBuilding command but uses a past tense name. That is a very important difference. Commands tell the application what it should do and events represent facts that have happened."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-2","title":"Yielding Events","content":"Aggregate methods can yield null, one domain event or multiple domain events depending on the result of the executed business logic. If an aggregate method yields null it indicates that no important fact happened and no event needs to be recorded. In many cases an aggregate method will yield one event which is the fact caused by the corresponding command. But there is no one-to-one connection between commands and events. In some cases more than one event is needed to communicate important facts or an error event is yielded instead of the expected event (we'll see that later).For the first use case we simply yield a BuildingAdded domain event when Building::add() is called with a AddBuilding command.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } } The special array syntax for yielding events is a short cut used by Event Machine. It creates the event based on given event name and payload and stores it in the event stream."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-3","title":"Aggregate Description","content":"If we switch back to the Swagger UI and send the AddBuilding command again, Event Machine still complains about a missing command handler. We need to tell Event Machine about our new aggregate and that it is responsible for handling AddBuilding commands. We can do this in another Event Machine Description in src\/Api\/Aggregate.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED); } } The connection between command and aggregate is described in a very verbose and readable way. Our IDE can suggest the describing methods of Event Machine's fluent interface and it is easy to remember each step. process tells Event Machine that the following description is for the given command name. withNew\/withExisting tells Event Machine which aggregate handles the command and if the aggregate exists already or a new one should be created. identifiedBy tells Event Machine which message payload property should be used to identify the responsible aggregate. Every command sent to the aggregate and every event yielded by the aggregate should contain this property handle takes a callable argument which is the aggregate method responsible for handling the command defined in process. We use the callable array syntax of PHP which can be analyzed by modern IDEs like PHPStorm for auto completion and refactorings. recordThat tells Event Machine which event is yielded by the aggregate's command handling method. If we try again to send AddBuilding we get a new error:{ \"error\": { \"message\": \"No apply function specified for event: BuildingAdded\", \"details\": \"...\" } } Command handling works now but an apply function is missing. In part III of the tutorial you'll learn how to add such a function and why it is needed."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4","title":"Part III - Aggregate State","content":"In part II we took a closer look at pure aggregate functions (implemented as static class methods in PHP because of missing function autoloading capabilities). Pure functions don't have side effects and are stateless. This makes them easy to test and understand. But an aggregate without state? How can an aggregate protect invariants (its main purpose) without state?The aggregate needs a way \"to look back\". It needs to know what happened in the past according to its own lifecycle. Without its current state and without information about past changes the aggregate could only execute business logic and enforce business rules based on the given information of the current command passed to a handling function. In most cases this is not enough.The functional programming solution to that problem is to pass the current state (which is computed from the past events recorded by the aggregate) to each command handling function (except the one handling the first command). This means that aggregate behaviour (command handling functions) and aggregate state (a data structure of a certain type) are two different things and separated from each other. How this is implemented in Event Machine is shown in this part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4-1","title":"Applying Domain Events","content":"Aggregate state is computed by iterating over all recorded domain events of the aggregate history starting with the oldest event. Event Machine does not provide a generic way to compute current state, instead the aggregate should have an apply function for each recorded event. Those apply functions are often prefixed with when followed by the event name.Let's add such a function for our BuildingAdded domain event.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { \/\/@TODO: Return new state for the aggregate } } BuildingAdded communicates that a new lifecycle of a building was started (new building was added to our system), so the Building::whenBuilidngAdded() function has to return a new state object and does not receive a current state object as an argument (next when* function will receive one!).But what does the State object look like? Well, you can use whatever you want. Event Machine does not care about a particular implementation (see docs for details). However, Event Machine ships with a default implementation of an ImmutableRecord. We use that implementation in the tutorial, but it is your choice if you want to use it in your application, too.Create a State class in src\/Model\/Building (new directory):&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } } Note: You can use PHPStorm to generate the Getter-Methods. You only have to write the private properties and add the doc blocks with @var type hints. Then use PHPStorm's ability to add the Getter-Methods (ALT+EINF). By default PHPStorm sets a get* prefix for each method. However, immutable records don't have setter methods and don't work with the get* prefix. Just change the template in your PHPStorm config: Settings -&gt; Editor -&gt; File and Code Templates -&gt; PHP Getter Method to:\/** * @return ${TYPE_HINT} *\/ public ${STATIC} function ${FIELD_NAME}()#if(${RETURN_TYPE}): ${RETURN_TYPE}#else#end { #if (${STATIC} == \"static\") return self::$${FIELD_NAME}; #else return $this-&gt;${FIELD_NAME}; #end } Now we can return a new Building\\State from Building::whenBuilidngAdded().&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } } Finally, we have to tell Event Machine about that apply function to complete the AddBuilding use case description. In src\/Api\/Aggregate:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) \/\/Map recorded event to apply function -&gt;apply([Building::class, 'whenBuildingAdded']); } } We're done with the write model for the first use case. If you send the AddBuilding command again using Swagger UI:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } ... you should receive a [202] command accepted responseEvent Machine emphasizes a CQRS and Event Sourcing architecture. For commands this means that no data is returned. The write model has received and processed the command AddBuilding successfully but we don't know what the new application state looks like. We will use a query, which is the third message type, to get this data. Head over to tutorial part IV to learn more about queries and application state management using projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5","title":"Part IV - Projections and Queries","content":"In part III of the tutorial we successfully implemented the first write model use case: Add a new building. Connect to the Postgres database and check the event stream table _4228e4a00331b5d5e751db0481828e22a2c3c8ef. The table should contain the first domain event yielded by the Building aggregate and recorded by event machine. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 If you're wondering why the event stream table has a sha1 hashed name this is because by default prooph\/event-store uses that naming strategy to avoid database vendor specific character constraints. You can however configure a different naming strategy if you don't like it.The write model only needs an event stream to store information but the read side has a hard time querying it. As long as we only have a few events in the stream queries are simple and fast. But over time this table will grow and contain many different events. To stay flexible we need to separate the write side from the read side. And this is done using so called projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-1","title":"Registering Projections","content":"Projections in Event Machine make use of the projection feature shipped with prooph\/event-store. An important difference is that by default Event Machine uses a single long-running PHP process to manage those projections. This way processing order of events is always the same (FIFO). A disadvantage is that projections are slower because of the sequential processing.But don't worry: If projections become a bottleneck you can simply switch to plain prooph\/event-store projections and run them in parallel. The recommendation is to switch to that approach only if it is really needed. Deploying and coordinating multiple projection processes requires a good (project specific) strategy and tools.Ok enough theory. Let's get back to the beauty and simplicity of Event Machine. You can use a shortcut if aggregate state should be available as a read model. You only need one of the available EventMachine\\Persistence\\DocumentStore implementations. By default the skeleton uses proophsoftware\/postgres-document-store but you can also use proophsoftware\/mongo-document-store or implement your own. See Event Machine docs for details.We only need to register an aggregate projection in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { \/** * You can register aggregate and custom projections in event machine * * For custom projection you should define a unique projection name using a constant * * const USER_FRIENDS = 'UserFriends'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); } } That's it. If you look into the Postgres DB you should see a new table called em_ds_building_projection_0_1_0. And the table should contain one row with two columns id and doc with id being the buildingId and doc being the JSON representation of the Building\\State.Note: If you cannot see the table please check the troubleshooting section of event-machine-skeleton README.You can learn more about projections in the docs. For now it is enough to know how to register them. Let's complete the picture and query the projection table using Swagger UI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-2","title":"Query, Resolver and Return Type","content":"We already know that Event Machine uses JSON Schema to describe message types and define validation rules. For queries we can also register return types in Event Machine and those return types will appear in the Model section of the Swagger UI.Registering types is done in src\/Api\/Type:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; private static function healthCheck(): ObjectType { return JsonSchema::object([ 'system' =&gt; JsonSchema::boolean() ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); } } As you can see the HealthCheck type used by the HealthCheck query is already registered here. We simply add Building\\State as the second type and use the aggregate type as name for the building type.Note: Types are described using JSON Schema. Building\\State implements ImmutableRecord and therefore provides the method ImmutableRecord::__schema (provided by ImmutableRecordLogic trait) which returns a JSON Schema object.Note: Using aggregate state as return type for queries couples the write model with the read model. However, you can replace the return type definition at any time. So we can use the short cut in an early stage and switch to a decoupled version later.Next step is to register the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(\/* ??? *\/) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Queries are named like the \"things\" they return. This results in a clean and easy to use messagebox schema.Please note that the return type is a reference: JsonSchema::typeRef().Last but not least, the query needs to be handled by a so-called finder (prooph term).When the query is sent to the messagebox endpoint it is translated into a query message that is passed on to prooph's query bus. The query message is validated against the schema defined during query registration $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object(...)).Our first query has a required argument, buildingId, which should be a valid Uuid. An invalid uuid will fail when the query is parsed into a Event Machine message.Long story short, we need a finder, as described in the prooph docs: QueryBus: much the same as the command bus but the message handler is invoked with the query message and a React\\Promise\\Deferred that needs to be resolved by the message handler aka finder. Create a new class called BuildingFinder in a new directory Finder in src\/Infrastructure.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use React\\Promise\\Deferred; final class BuildingFinder { public function __invoke(Message $buildingQuery, Deferred $deferred): void { \/\/@TODO: resolve $deferred } } This is an invokable finder, as described in the prooph docs. It receives the query message as the first argument and a React\\Promise\\Deferred as the second argument. prooph's query bus can be used in an async, non-blocking I\/O runtime as well as a normal, blocking runtime, so the finder must resolve the deferred object instead of returning a result. We work with the Promise and Deferred objects provided by the ReactPHP library (unfortunately, we have no PSR for promises yet). Event Machine takes care of resolving promises returned by prooph's query bus.The finder needs to query the read model. While looking at projections we briefly discussed Event Machine's DocumentStore API. The finder can use it to access documents organized in collections. Let's see how that works.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { $buildingId = $buildingQuery-&gt;get('buildingId'); $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } } The implementation is self explanatory, but a few notes should be made.Every Event Machine message has a get and a getOrDefault method which are both short cuts to access keys of the message payload. The difference between the two is obvious. If the payload key is NOT set and you use get the message will throw an exception. If the payload key is NOT set and you use getOrDefault you get back the default passed as the second argument.The second note is about the collection name. It is injected at runtime rather than defined as a hardcoded string or constant. Do you remember the read model table name em_ds_building_projection_0_1_0? First of all, this is also a default naming strategy and can be changed. However, the interesting part here is the version number at the end of the name. This is the application version which you can pass to EventMachine::boostrap() (see docs for details). When deploying a new application version it is possible to rebuild all projection tables using the new version while the old projection tables remain active until load balancers are switched (Blue Green Deployment).Finally, we need to configure Event Machine's DI container to inject the dependencies into our new finder."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-3","title":"PSR-11 Container","content":"Event Machine can use any PSR-11 compatible container. By default it uses a very simple implementation included in the Event Machine package. The DI container is inspired by bitExpert\/disco but removes the need for annotations. Dependencies are managed in a single ServiceFactory class which is located in src\/Service.Just add the following method to the ServiceFactory:&lt;?php namespace App\\Service; \/\/New use statements use App\\Api\\Aggregate; use App\\Infrastructure\\Finder\\BuildingFinder; use Prooph\\EventMachine\\Projecting\\AggregateProjector; \/\/Other use statements use ... final class ServiceFactory { \/* ... *\/ public function setContainer(ContainerInterface $container): void { $this-&gt;container = $container; } \/\/Finders public function buildingFinder(): BuildingFinder \/\/&lt;-- Return type is used as service id { \/\/Service is treated as a singleton, DI returns the same instance on subsequent gets return $this-&gt;makeSingleton(BuildingFinder::class \/*&lt;-- again service id *\/, function () { return new BuildingFinder( \/\/We can use the AggregateProjector to generate correct collection name AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), \/\/&lt;-- Inside a closure we still have access to other methods Aggregate::BUILDING \/\/ of the ServiceFactory, like the getter for Event Machine itself ), $this-&gt;documentStore() \/\/ or the document store ); }); } \/* ... *\/ } And use BuildingFinder::class as the finder service id when registering the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; \/\/&lt;-- New use statement use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) \/\/&lt;-- Finder service id -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Ok! We should be able to query buildings by buildingId now. Switch to Swagger and reload the schema (press the \"explore\" button). The Documentation Explorer should show a new Query: Building. If we send that query with the buildingId used in AddBuilding:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } We get back:{ \"name\": \"Acme Headquarters\", \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } Awesome, isn't it?"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-4","title":"Optional Query Arguments","content":"Finders can also handle multiple queries. This is useful when multiple queries can be resolved by accessing the same read model collection. A second query for the BuildingFinder would be a query that lists all buildings or a subset filtered by name.Add the query to src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; \/\/&lt;-- New query, note the plural public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); \/\/New query $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], \/\/No required arguments for this query \/\/Optional argument name, is a nullable string ['name' =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) \/\/Resolve query with same finder ... -&gt;resolveWith(BuildingFinder::class) \/\/... but return an array of Building type -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } The refactored BuildingFinder looks like this:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get('buildingId')); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault('name', null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter('name', \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } BuildingFinder can resolve both queries by mapping the query name to an internal resolve* method. For the new Buildings query the finder makes use of DocumentStore\\Filters. The LikeFilter works the same way as a SQL like expression using % as a placeholder. AnyFilter matches any documents in the collection. There are many more filters available. Read more about filters in the docs.You can test the new query using Swagger. This is an example query with a name filter:{ \"payload\": { \"name\": \"Acme\" } } You can add some more buildings and play with the queries. Try to exchange the LikeFilter with a EqFilter for example. Or see what happens if you pass an empty string as name filter.In part VI we got back to the write model and learned how to work with process managers. But before we continue, we should clean up our code a bit. Part V tells you what we can improve."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6","title":"Part V - DRY","content":"You may have noticed that we use the static classes in src\/Api as a central place to define constants. At least we did that for message (Command, Event, Query) and aggregate names. We did not touch src\/Api\/Payload and src\/Api\/Schema yet.The idea behind those two classes is to group some common constants and static methods so that we don't have to repeat them over and over again. This makes it much easier to refactor the codebase later."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-1","title":"Payload","content":"In src\/Api\/Payload we simply define a constant for each possible message payload key. We've used two keys so far: buildingId and name so we should add them ...&lt;?php declare(strict_types=1); namespace App\\Api; class Payload { \/\/Predefined keys for query payloads, see App\\Api\\Schema::queryPagination() for further information const SKIP = 'skip'; const LIMIT = 'limit'; const BUILDING_ID = 'buildingId'; const NAME = 'name'; } ... and replace plain strings with the constants in our codebase:src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } src\/Infrastructure\/Finder\/BuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get(Payload::BUILDING_ID)); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault(Payload::NAME, null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter(Payload::NAME, \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-2","title":"Schema","content":"Schema definitions are another area where DRY (Don't Repeat Yourself) makes a lot of sense. A good practice is to define a schema for each payload key and reuse it when registering messages. Type references (JsonSchema::typeRef) should also be wrapped by a schema method. Open src\/Api\/Schema and add the static methods:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { public static function buildingId(): UuidType { return JsonSchema::uuid(); } public static function buildingName(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function buildingNameFilter(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function building(): TypeRef { return JsonSchema::typeRef(Aggregate::BUILDING); } public static function buildingList(): ArrayType { return JsonSchema::array(self::building()); } \/* ... *\/ } Doing this creates one place that gives us an overview of all domain specific schema definitions and we can simply change them if requirements change.Note: Even if we only use \"name\" in message payload for building names we use a more precise method name in Schema. A message defines the context so we can use a shorter payload key but the schema should be explicit.You can now replace all schema definitions.src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::building()); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(Schema::buildingNameFilter())] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::buildingList()); } } We're done with the refactoring and ready to add the next use case. Head over to part VI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7","title":"Part VI - Check in User","content":"The second use case of our Building Management system checks users into buildings. Users are identified by their name."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-1","title":"Command","content":"Let's add a new command for the use case in src\/Api\/Command:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerCommand( Command::CHECK_IN_USER, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } We can reuse Payload::NAME but assign a different schema so that we can change schema for a building name without influencing the schema of user name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-2","title":"Event","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); $eventMachine-&gt;registerEvent( self::USER_CHECKED_IN, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-3","title":"Aggregate","content":"Did you notice that we are getting faster? Once, you're used to Event Machine's API you can develop at the speed of light ;).A user can only check into an existing building. builidngId is part of the command payload and should reference a building in our system. For the command handling aggregate function this means that we also have state of the aggregate and Event Machine will pass that state as the first argument to the command handling function as well as to the event apply function:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } Building::checkInUser() is still a dumb function (we will change that in a minute) but Building::whenUserCheckedIn() contains an interesting detail. Building\\State is an immutable record. But we can add with* methods to it to modify state. You may know these with* methods from the PSR-7 standard. It is a common practice to prefix state changing methods of immutable objects with with. Those methods should return a new instance with the modified state rather than changing its own state. Here is the implementation of Building\\State::withCheckedInUser(string $username): Building\\State:&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use App\\Api\\Schema; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @var array *\/ private $users = []; public static function __schema(): Type { return self::generateSchemaFromPropTypeMap([ 'users' =&gt; ImmutableRecord::PHP_TYPE_STRING ]); } \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } \/** * @return array *\/ public function users(): array { return array_keys($this-&gt;users); } public function withCheckedInUser(string $username): State { $copy = clone $this; $copy-&gt;users[$username] = null; return $copy; } public function isUserCheckedIn(string $username): bool { return array_key_exists($username, $this-&gt;users); } } We can make a copy of the record and modify that. The original record is not modified, and we return the copy to satisfy the immutable record contract.Besides withCheckedInUser we've added a new property, users, and a getter for it. We also overrode the private static method arrayPropItemTypeMap of ImmutableRecordLogic to define a type hint for the items in the users array property. Unfortunately, we can only type hint for array in PHP, and it is not possible to use return type hints like string[]. Hopefully this will change in a future version of PHP, but, for now, we have to live with the workaround and give ImmutableRecordLogic a hint that array items of the users property are of type string.Note: ImmutableRecordLogic derives type information by inspecting return types of getter methods named like their corresponding private properties.Internally, user names are used as the array index so the same user cannot appear twice in the list. With Building\\State::isUserCheckedIn(string $username): bool we can look up if the given user is currently in the building. Building\\State::users() on the other hand returns a list of user names like defined in the __schema. Internal state is used for fast look ups and external schema is used for the read model. More on that in a minute."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-4","title":"Command Processing","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']); } } Pretty much the same command processing description but with command, event and function names based on the new use case. An important difference is that we use -&gt;withExisting instead of -&gt;withNew. As already stated this tells Event Machine to look up an existing Building using the buildingId from the CheckInUser command.The following command should check in John into the Acme Headquarters.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Looks good! And what does the response of the Buildings query look now? If you inspect the schema of the query and click on the Building return type you'll notice the new property users.{ \"payload\": { \"name\": \"Acme\" } } Response[ { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } ] Great! We get back the list of users checked into the building."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-5","title":"Protect Invariants","content":"One of the main tasks of an aggregate is to protect invariants. A user cannot check in twice. The Building aggregate should enforce the business rule:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { throw new \\DomainException(sprintf( \"User %s is already in the building\", $checkInUser-&gt;get(Payload::NAME) )); } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } The command handling function can make use of $state passed to it as this will always be the current state of the aggregate. If the given user is already checked in we throw an exception to stop command processing.Let's try it:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Response:{ \"error\": { \"message\": \"User John is already in the building\", \"details\": \"...\" } } Throwing an exception is the simplest way to protect invariants. However, with event sourcing we have a different (and in most cases) better option. This will be covered in the next part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8","title":"Part VII - The Unhappy Path","content":"Developers tend to work out the happy path of a feature only and throw exceptions in every unknown situation. This behaviour is often caused by bad project management. Developers get domain knowledge from Jira tickets written by a product owner (Jira is used here as a synonym for any ticket system used in an agile process) instead of talking to domain experts face-to-face. Most tickets don't include unhappy paths until they happen and find their way back to the developer as a bug ticket.Is this really the best way to deal with unexpected scenarios? Wouldn't it be better to prepare for the unhappy paths as well? Sure, it takes more time upfront but saves a lot of time later when the application runs in production and can deal with failure scenarios in a sane way.Our Building aggregate does a bad job with regards to failure handling. Imagine a user is already in a building and tries to check in again. What does that mean in the real world? First of all it is not possible to be in and out of a building at the same time. So either a hacker has stolen the identity or system state is broken for whatever reason. Deciding if entrance to the building is blocked or not should be made by the business. And regardless of the decision it is always interesting to have an event in the event stream about the double check in. This makes monitoring much simpler than scanning error logs.We've talked to the domain experts and they want us to notify security in case of a DoubleCheckIn. With Event Machine this is as simple as throwing an exception ;)We need an event to record a DoubleCheckIn:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerEvent( self::DOUBLE_CHECK_IN_DETECTED, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } Now that we have the event we can replace the exception and yield a DoubleCheckInDetected event instead:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { yield [Event::DOUBLE_CHECK_IN_DETECTED, $checkInUser-&gt;payload()]; return; \/\/&lt;-- Note: we need to return, otherwise UserCheckedIn would be yielded, too } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } public static function whenDoubleCheckInDetected(Building\\State $state, Message $event): Building\\State { \/\/No state change required, simply return current state return $state; } } We need to tell Event Machine that Building::checkInUser() yields DoubleCheckInDetected in some situations:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([Building::class, 'whenDoubleCheckInDetected']); } } Try to check John in again:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Instead of an error we get a 202 command accepted response.But when we look at the event stream (table _4228e4a00331b5d5e751db0481828e22a2c3c8ef) we see a DoubleCheckInDetected event. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 2 0ee8d2fb-... UserCheckedIn {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"1ce0e46d-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 2} 2018-02-16 21:37:55.131122 3 4f6a8429-... DoubleCheckInDetected {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"c347dd85-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 3} 2018-02-16 23:03:59.739666 "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-1","title":"Process Manager","content":"To complete the user story we have to notify security. The security team uses a dedicated monitoring application that can receive arbitrary notification messages. To communicate with that external system we can use a so-called process manager or policy. Maybe you're more familiar with the term event listener but be careful to not mix it with event listeners known from web frameworks like Symfony or Zend. Listeners in Event Machine react to domain events and trigger follow up commands for actions, like sending emails or interacting with external systems.We can simulate the security monitoring system with a small JS app shipped with the event-machine-skeleton. Open http:\/\/localhost:8080\/ws.html in your browser.Note: If the app shows a connection error then try to log into the rabbit mgmt console first: https:\/\/localhost:8081. Accept the self-signed certificate and login with usr: prooph pwd: prooph. If you're logged in switch back to http:\/\/localhost:8080\/ws.html and reload the page.If the app says Status: Connected to websocket: ui-queue it is ready to receive messages from Event Machine.In src\/Service\/ServiceFactory you can find a factory method for a App\\Infrastructure\\ServiceBus\\UiExchange. It's a default domain event listener shipped with the skeleton that can be used to push events on a RabbitMQ ui-exchange. The exchange is preconfigured (you can see that in the rabbit mgmt UI) and the JS app connects to a corresponding ui-queue.In src\/Api\/Listener we can put together the pieces:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\ServiceBus\\UiExchange; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Listener implements EventMachineDescription { public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;on(Event::DOUBLE_CHECK_IN_DETECTED, UiExchange::class); } } Whenever a DoubleCheckInDetected event is recorded and written to the stream Event Machine invokes the UiExchange listener that takes the event and pushes it to rabbit.Try to check John in again, while keeping an eye on the monitoring app http:\/\/localhost:8080\/ws.html.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } ]"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-2","title":"The End","content":"Congratulations! You've mastered the Event Machine tutorial. There are two bonus parts available to learn more about custom projections and testing with Event Machine. The current implementation is available as a demo branch of proophsoftware\/event-machine-skeleton. There is a second branch called demo-oop available that contains a similar implementation, but the Building aggregate is designed using an object oriented approach rather than the functional approach shown in the tutorial. If you like that OOP style more you can of course use that.Functional programming fans might dislike the static class methods. You can also use real functions instead of static class methods, but you have to configure composer to always require the files containing your functions. It's up to you.The Event Machine API docs contain a lot more details. Last but not least, a reminder that the prooph software team offers commercial project support and workshops for Event Machine and the prooph components.Our workshops include Event Storming sessions and guidance on how to turn the results into working prototypes using Event Machine. We can also show and discuss framework integrations. Event Machine can easily be integrated with Symfony, Laravel and other PHP web frameworks. The skeleton is based on Zend Strategility so you can handle http related tasks, like authentication, using PSR-15 middleware. But again, other web frameworks play nicely with Event Machine, too.If you are interested please get in touch!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9","title":"Bonus I - Custom Projection","content":"The product owner comes along with a new feature request. They need a way to look up the building a user is checked into, if any."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-1","title":"Exercise","content":"Before we implement that feature you're asked to implement the check out user use case. Add a command CheckOutUser and an event UserCheckedOut. Let the Building aggregate and Building\\State handle the command and make sure that DoubleCheckOutDetected can also be monitored using the monitoring UI.Does it work? Great!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-2","title":"Implement a Projector","content":"What we need is a list of usernames and a reference to the building they are checked into. A custom projection can keep track of UserCheckedIn and UserCheckedOut events to keep the list up-to-date.First check in John again (in case he is checked out because you've successfully tested the CheckOutUser command)!To do that we need our own Prooph\\EventMachine\\Projecting\\Projector implementation. Create a new class called UserBuildingList in src\/Infrastructure\/Projector with the following content:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; use Prooph\\EventMachine\\Projecting\\Projector; final class UserBuildingList implements Projector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $appVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection($this-&gt;generateCollectionName($appVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( $this-&gt;generateCollectionName($appVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $appVersion, string $projectionName, Message $event): void { $collection = $this-&gt;generateCollectionName($appVersion, $projectionName); switch ($event-&gt;messageName()) { case Event::USER_CHECKED_IN: $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;get(Payload::NAME), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;get(Payload::BUILDING_ID)] ); break; case Event::USER_CHECKED_OUT: $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;get(Payload::NAME)); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection($this-&gt;generateCollectionName($appVersion, $projectionName)); } private function generateCollectionName(string $appVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection, too return AggregateProjector::generateCollectionName($appVersion, $projectionName); } } Make the projector available as a service in src\/Service\/ServiceFactory:&lt;?php namespace App\\Service; use App\\Infrastructure\\Projector\\UserBuildingList; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function buildingFinder(): BuildingFinder { return $this-&gt;makeSingleton(BuildingFinder::class, function () { return new BuildingFinder( AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ), $this-&gt;documentStore() ); }); } \/\/Projectors public function userBuildingListProjector(): UserBuildingList { return $this-&gt;makeSingleton(UserBuildingList::class, function () { return new UserBuildingList($this-&gt;documentStore()); }); } \/* ... *\/ } And describe the projector in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Projector\\UserBuildingList; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { const USER_BUILDING_LIST = 'user_building_list'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;with(self::USER_BUILDING_LIST, UserBuildingList::class) -&gt;filterEvents([ Event::USER_CHECKED_IN, Event::USER_CHECKED_OUT, ]); } } If you look at the Postgres DB you should see a new table called em_ds_user_building_list_0_1_0 but the table is empty. We can reset the long-running projection process used by Event Machine and therefor recreate all read models. This will fill the new read model with data from the past. That's cool, isn't it?Run the command docker-compose run php php bin\/reset.php in the project directory and check the table again.Here we go: id doc John {\"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\"} "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-3","title":"Look up","content":"We can add a new query, finder and corresponding type definitions to complete the look up feature.src\/Api\/Type&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const USER_BUILDING = 'UserBuilding'; \/\/&lt;-- new type \/* ... *\/ private static function userBuilding(): ObjectType { return JsonSchema::object([ 'user' =&gt; Schema::username(), 'building' =&gt; Schema::building()-&gt;asNullable(), \/\/&lt;-- type ref to building, can be null ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); $eventMachine-&gt;registerType(self::USER_BUILDING, self::userBuilding()); \/\/&lt;-- type registration } } src\/Api\/Schema&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function userBuilding(): TypeRef { return JsonSchema::typeRef(Type::USER_BUILDING); } \/* ... *\/ } src\/Infrastructure\/Finder\/UserBuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class UserBuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function __invoke(Message $query, Deferred $deferred): void { $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;get(Payload::NAME) ); if(!$userBuilding) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; $building ]); return; } } src\/Service\/ServiceFactory&lt;?php namespace App\\Service; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function userBuildingFidner(): UserBuildingFinder { return $this-&gt;makeSingleton(UserBuildingFinder::class, function () { return new UserBuildingFinder( $this-&gt;documentStore(), AggregateProjector::generateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Projection::USER_BUILDING_LIST ), AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ) ); }); } \/* ... *\/ } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ \/* ... *\/ const USER_BUILDING = 'UserBuilding'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery( self::USER_BUILDING, JsonSchema::object(['name' =&gt; Schema::username()]) ) -&gt;resolveWith(UserBuildingFinder::class) -&gt;setReturnType(Schema::userBuilding()); } } Swagger - UserBuilding query{ \"payload\": { \"name\": \"John\" } } Response{ \"user\": \"John\", \"building\": { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } An hour of work (with a bit more practice even less) and we are ready to ship the new feature! Rapid application development at its best! RAD is ok, but please don't skip testing! In the second bonus part of the tutorial we'll learn that Event Machine makes it easy to run integration tests. Don't miss it!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10","title":"Bonus II - Unit and Integration Tests","content":"Unit testing the different parts of the application is easy. In most cases we have single purpose classes and functions that can be tested without mocking."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-1","title":"Testing Aggregate functions","content":"Aggregate functions are pure which makes them easy to test. event-machine-skeleton provides some test helpers in tests\/BaseTestCase.php, so, if you extend from that base class, you're ready to go. Add a folder Model in tests and a class BuildingTest with the following content:&lt;?php declare(strict_types=1); namespace AppTest\\Model; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use AppTest\\BaseTestCase; use Ramsey\\Uuid\\Uuid; use App\\Model\\Building; class BuildingTest extends BaseTestCase { private $buildingId; private $buildingName; private $username; protected function setUp() { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } \/** * @test *\/ public function it_detects_double_check_in() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); $state = $state-&gt;withCheckedInUser($this-&gt;username); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::DOUBLE_CHECK_IN_DETECTED, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); \/\/And the other way round, list should not contain event with given name $this-&gt;assertNotRecordedEvent(Event::USER_CHECKED_IN, $events); } } You can run tests with:docker-compose run php php vendor\/bin\/phpunit "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-2","title":"Testing Projectors","content":"Testing projectors is also easy when they use the DocumentStore API to manage projections. Event Machine ships with an InMemoryDocumentStore implementation that works great in test cases. Here is an example:tests\/Infrastructure\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\Projector\\UserBuildingList; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; final class UserBuildingListTest extends BaseTestCase { const APP_VERSION = '0.1.0'; const PROJECTION_NAME = 'user_building_list'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var DocumentStore *\/ private $documentStore; \/** * @var UserBuildingList *\/ private $projector; protected function setUp() { parent::setUp(); $this-&gt;documentStore = new DocumentStore\\InMemoryDocumentStore(); $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun(self::APP_VERSION, self::PROJECTION_NAME); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = AggregateProjector::generateCollectionName(self::APP_VERSION, self::PROJECTION_NAME); $johnCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $janeCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = $this-&gt;message(Event::USER_CHECKED_OUT, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedOut); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-3","title":"Testing Finders","content":"Finders can be tested in the same manner as projectors, using the InMemoryDocumentStore with prefilled data. I will leave implementing these tests as an exercise for you ;)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-4","title":"Integration Tests","content":"If you want to test the \"whole thing\" then you can make use of Event Machine's test mode. In test mode Event Machine is set up with an InMemoryEventStore and an InMemoryDocumentStore. A special PSR-11 container ensures that all other services are mocked. Let's see it in action. The annotated integration test should be self explanatory.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Integration; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\ServiceBus\\UiExchange; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Messaging\\Message; final class NotifySecurityTest extends BaseTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp() { \/\/The BaseTestCase loads all Event Machine descriptions configured in config\/autoload\/global.php parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke(Message $event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage(): Message { return $this-&gt;lastReceivedMessage; } }; } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { $this-&gt;eventMachine-&gt;bootstrapInTestMode( \/\/Add history events that should have been recorded before current test scenario [ $this-&gt;message(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ], \/\/Provide mocked services used in current test scenario, if you forget one the test will throw an exception \/\/You don't have to mock the event store and document store, that is done internally [ \/\/Remember, UiExchange is our process manager that pushes events to rabbit \/\/Event Machine is configured to push DoubleCheckInDetected events on to UiExchange (src\/Api\/Listener.php) UiExchange::class =&gt; $this-&gt;uiExchange ] ); \/\/Try to check in John twice $checkInJohn = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventMachine-&gt;dispatch($checkInJohn); \/\/After dispatch $this-&gt;lastPublishedEvent points to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals(Event::DOUBLE_CHECK_IN_DETECTED, $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;messageName()); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;payload()); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1","title":"Installation","content":"Event Machine is not a full stack framework. Instead you integrate it in any PHP framework that supports PHP Standards Recommendations."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-1","title":"Skeleton","content":"The easiest way to get started is by using the skeleton. It ships with a preconfigured Event Machine, a recommended project structure, ready-to-use docker containers and Zend Strategility to handle HTTP requests.The skeleton is not the only way to set up Event Machine. You can tweak set up as needed and integrate Event Machine with Symfony, Laravel or any other framework or middleware dispatcher."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2","title":"Required Infrastructure","content":"Event Machine is based on PHP 7.1 or higher. Package dependencies are installed using composer."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1","title":"Database","content":"Event Machine uses prooph\/event-store to store events recorded by the write model and a DocumentStore (see \"Document Store\" chapter) to store the read model.The skeleton uses prooph's Postgres event store and a Postgres Document Store implementation. This allows Event Machine to work with a single database, but that's not a requirement. You can mix and match as needed and also use a storage mechanism not implementing the document store interface by using custom projections (more on that in the \"projections\" chapter)."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1-1","title":"Creating The Event Stream","content":"All events are stored in a single stream. You cannot change this strategy and prooph\/event-store has to be set up with the SingleStreamStrategy! The reason for this is that projections rely on a guaranteed order of events. A single stream is the only way to fulfill this requirement. When using a relational database as an event store a single table is also very efficient. A longer discussion about the topic can be found in the prooph\/pdo-event-store repo.An easy way to create the needed stream is to use the event store API directly.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; use ArrayIterator; use Prooph\\EventStore\\EventStore; use Prooph\\EventStore\\Stream; use Prooph\\EventStore\\StreamName; require_once 'vendor\/autoload.php'; $container = require 'config\/container.php'; \/** @var EventStore $eventStore *\/ $eventStore = $container-&gt;get('EventMachine.EventStore'); $eventStore-&gt;create(new Stream(new StreamName('event_stream'), new ArrayIterator())); echo \"done.\\n\"; Such a script is used in the skeleton. As you can see we request the event store from a container that we get from a config file. The skeleton uses Zend Strategility and this is a common approach in Strategility (and Zend Expressive) based applications. If you want to use another framework, adopt the script accordingly. The only thing that really matters is that you get a configured prooph\/event-store from the PSR-11 container used by Event Machine."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1-2","title":"Read Model Storage","content":"Read Model storage is set up on the fly. You don't need to prepare it upfront, but you can if you prefer to work with a database migration tool. It is up to you. Learn more about read model storage set up in the projections chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-3","title":"Event Machine Descriptions","content":"Event Machine uses a \"zero configuration\" approach. While you have to configure integrated packages like prooph\/event-store, Event Machine itself does not require centralized configuration. Instead it loads so called Event Machine Descriptions:&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; interface EventMachineDescription { public static function describe(EventMachine $eventMachine): void; } Any class implementing the interface can be loaded by Event Machine. The task of a Description is to tell Event Machine how the application is structured. This is done in a programmatic way using Event Machine's registration API which we will cover in the next chapter. Here is a simple example of a Description that registers a command in Event Machine.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Command implements EventMachineDescription { const COMMAND_CONTEXT = 'MyContext.'; const REGISTER_USER = self::COMMAND_CONTEXT . 'RegisterUser'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( self::REGISTER_USER, \/\/&lt;-- Name of the command defined as constant above JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); } } Now we only need to tell Event Machine that it should load the Description:declare(strict_types=1); require_once 'vendor\/autoload.php'; $eventMachine = new EventMachine(); $eventMachine-&gt;load(App\\Api\\Command::class); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4","title":"Initialize &amp; Bootstrap","content":"Event Machine is bootstrapped in three phases. Descriptions are loaded first, followed by a $eventMachine-&gt;initialize($container, $appVersion) call. Finally, $eventMachine-&gt;bootstrap($environment, $debugMode) prepares the system so that it can handle incoming messages.Bootstrapping is split because the description and initialization phases can be skipped in production. Read more about this in \"Optimize for production\" chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4-1","title":"Initialize","content":"Before caching of the configuration is possible Event Machine needs to aggregate information from all Descriptions. This is done in the Initialize phase. The phase also requires a PSR-11 container that can be used by Event Machine to get third-party services. See section about dependency injection for details.The second argument of the initialize method is a string representing the application version. It defaults to 0.1.0. The application version comes into play when organizing projections. More details can be found in the projections chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4-2","title":"Bootstrap","content":"Last, but not least $eventMachine-&gt;bootstrap($environment, $debugMode) starts the engine and we're ready to take off. Event Machine supports 3 different environments: dev, prod and test. The environment is mainly used to set up third-party components like a logger.Same is true for the debug mode. It can be used to enable verbose logging or displaying of exceptions even if Event Machine runs in prod environment. You have to take care of this when setting up services. Event Machine just provides the information:Environment: $eventMachine-&gt;env(); \/\/ prod | dev | test Debug Mode: $eventMachine-&gt;debugMode(); \/\/ bool App Version: $eventMachine-&gt;appVersion(): \/\/ string -&gt; default: 0.1.0 "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2","title":"Dependency Injection","content":"As stated in the Initialize &amp; Bootstrap section, Event Machine pulls third-party dependencies from a PSR-11 container. It ships with its own 100 LoC container with the code name Disco Light (real class name is ReflectionBasedContainer). The implementation of Disco Light is inspired by the design of bitexpert\/disco but functionality is reduced to a bare minimum needed in a PHP 7.1+ environment. Hence, the code name ;)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-1","title":"Required Services","content":"The container needs to provide a list of services required by Event Machine. For each of them a constant is defined. See the table below: Constant Value Service Description Mandatory EventMachine::SERVICE_ID_EVENT_STORE EventMachine.EventStore prooph\/event-store v7 event store Yes EventMachine::SERVICE_ID_SNAPSHOT_STORE EventMachine.SnapshotStore prooph\/event-store v7 snapshot store No EventMachine::SERVICE_ID_COMMAND_BUS EventMachine.CommandBus prooph\/service-bus v6 command bus Yes EventMachine::SERVICE_ID_EVENT_BUS EventMachine.EventBus prooph\/service-bus v6 event bus Yes EventMachine::SERVICE_ID_QUERY_BUS EventMachine.QueryBus prooph\/service-bus v6 query bus Yes EventMachine::SERVICE_ID_PROJECTION_MANAGER EventMachine.ProjectionManager prooph\/event-store v7 projection manager Yes EventMachine::SERVICE_ID_DOCUMENT_STORE EventMachine.DocumentStore Store implementing DocumentStore interface No EventMachine::SERVICE_ID_ASYNC_EVENT_PRODUCER EventMachine.AsyncEventProducer prooph\/service-bus v6 message producer No EventMachine::SERVICE_ID_MESSAGE_FACTORY EventMachine.MessageFactory prooph\/common v4 message factory (default provided) No EventMachine::SERVICE_ID_JSON_SCHEMA_ASSERTION EventMachine.JsonSchemaAssertion Class implementing JsonSchemaAssertion interface (default provided) No "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-2","title":"Default Services","content":"Event Machine ships with a default implementation for the last two services, a dedicated EventMachineContainer that provides the services and a ContainerChain to merge your container with the defaults:$myCustomContainer = include 'config\/container.php'; $defaultsContainer = new \\Prooph\\EventMachine\\Container\\EventMachineContainer($eventMachine); $psr11ContainerChain = new \\Prooph\\EventMachine\\Container\\ContainerChain($myCustomContainer, $defaultsContainer); $eventMachine-&gt;initalize($psr11ContainerChain); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3","title":"Working With Disco Light","content":"Remember the origin of Event Machine. It was designed as a workshop framework first. So one of the nice things about Disco Light is that dependencies are not wired together by a magical component but instead by the developer. This way they can learn the different parts of the system and what configuration is needed to get everything to work together. In the Event Machine Skeleton we've done that for you. A single class called the ServiceFactory is responsible for providing all services.You can find the ServiceFactory of the skeleton here"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-1","title":"Service Ids","content":"Let's look at the method which provides the service EventMachine.EventStore:public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { $eventStore = new PostgresEventStore( $this-&gt;eventMachine()-&gt;messageFactory(), $this-&gt;pdoConnection(), $this-&gt;eventStorePersistenceStrategy() ); return new TransactionalActionEventEmitterEventStore( $eventStore, new ProophActionEventEmitter(TransactionalActionEventEmitterEventStore::ALL_EVENTS) ); }); } A lot of stuff going on here, so we'll look at it step by step.public function eventStore(): EventStore All public methods of the ServiceFactory are scanned by Disco Light (\\Prooph\\EventMachine\\Container\\ReflectionBasedContainer). The return type of the method is used as as service id. This means that you can do the following to get the event store from the container:$eventStore = $container-&gt;get(EventStore::class); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-2","title":"Singleton Service","content":"In most cases we want to get the same instance of a service from the container no matter how often we request it. This is called a Singleton. Disco Light is dead simple. It does not know anything about singletons. Instead we use a pattern called memoization to cache the instance of a service in memory and return it from cache on subsequent calls.The ServiceFactory is a complete userland implementation. No interface needs to be implemented. To add memoization to your service factory you can use the provided trait \\Prooph\\EventMachine\\Container\\ServiceRegistry like it is done in the skeleton service factory.final class ServiceFactory { use ServiceRegistry; Now you can store service instances in memory:public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { \/\/... }); } You might recognize that we use EventStore::class again as service id for the registry. The second argument of makeSingleton is a closure which acts as a factory function for the service. When EventStore::class is not in the cache, the factory function is called otherwise the service is returned from the registry."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-3","title":"Injecting Dependencies in a Service","content":"Often one service depends on other services. The Postgres event store used in the skeleton for example requires a MessageFactory a \\PDO connection and a PersistenceStrategy and because all services are provided by the same ServiceFactory we can simply get those services by calling the appropriate methods.By default a closure is bound to its parent scope (the service factory instance in this case). Hence, insight the closure we have access to all methods of the service factory no matter if they are declared public, protected or private.public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { $eventStore = new PostgresEventStore( $this-&gt;eventMachine()-&gt;messageFactory(), $this-&gt;pdoConnection(), $this-&gt;eventStorePersistenceStrategy() ); return new TransactionalActionEventEmitterEventStore( $eventStore, new ProophActionEventEmitter(TransactionalActionEventEmitterEventStore::ALL_EVENTS) ); }); } The event store interface is service id and return type at the same time. Therefor, PHP's type system ensures at runtime that a valid event store is returned. Internally, we built a Postgres event store and add prooph's plugin system (the TransactionalActionEventEmitterEventStore). If we want to switch the event store we can return another implementation."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-4","title":"Configuration","content":"Another thing that is out of scope for Disco Light is application configuration. Remember, providing a working ServiceFactory is your task and if services need configuration then pass it to the class. In the skeleton environmental variables are mapped to config params in config\/autoload\/global.php.The configuration array is then passed to the ServiceFactory in the constructor and wrapped with an ArrayReader:final class ServiceFactory { use ServiceRegistry; \/\/... public function __construct(array $appConfig) { $this-&gt;config = new ArrayReader($appConfig); } This way we have access to the configuration when building our services. We can see this in action in the factory method of the \\PDO connection:public function pdoConnection(): \\PDO { return $this-&gt;makeSingleton(\\PDO::class, function () { $this-&gt;assertMandatoryConfigExists('pdo.dsn'); $this-&gt;assertMandatoryConfigExists('pdo.user'); $this-&gt;assertMandatoryConfigExists('pdo.pwd'); return new \\PDO( $this-&gt;config-&gt;stringValue('pdo.dsn'), $this-&gt;config-&gt;stringValue('pdo.user'), $this-&gt;config-&gt;stringValue('pdo.pwd') ); }); } $this-&gt;assertMandatoryConfigExists(\/*...*\/) is a helper function of the ServiceFactory marked as private. It is ignored by Disco Light but we can use it within factory functions.private function assertMandatoryConfigExists(string $path): void { if(null === $this-&gt;config-&gt;mixedValue($path)) { throw new \\RuntimeException(\"Missing application config for $path\"); } } Again, this is all userland implementation. Disco Light does not care about it. If you don't like it to put all services in a single class then use traits and only merge them in the ServiceFactory. And if you don't like the approach at all, use another PSR-11 container! In any case you can learn from the skeleton service factory how the mandatory services need to be wired together. Porting this knowledge to a container of your choice shouldn't be a problem."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-5","title":"Service Alias","content":"If you've read the explanations above carefully, you might have noticed a mismatch between the service id required by Event Machine and the service id used in Disco Light. Event Machine requires the service id EventMachine.EventStore. But we've learned that we get the event store by using the interface or class name as service id $eventStore = $container-&gt;get(EventStore::class);.To solve the conflict we need a service alias. That said, the same service needs to be available in the container with two different ids. We can do this by passing a service alias map to Disco Light aka ReflectionBasedContainer:$container = new \\Prooph\\EventMachine\\Container\\ReflectionBasedContainer( $serviceFactory, [ \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_STORE =&gt; \\Prooph\\EventStore\\EventStore::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_PROJECTION_MANAGER =&gt; \\Prooph\\EventStore\\Projection\\ProjectionManager::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_COMMAND_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\CommandBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\EventBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_QUERY_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\QueryBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_DOCUMENT_STORE =&gt; \\Prooph\\EventMachine\\Persistence\\DocumentStore::class, ] ); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-4","title":"Put it all together","content":"Again, we can look at the skeleton for a working example. [config\/container.php]: includes the application config passes it to a new instance of the ServiceFactory passes the ServiceFactory and service alias map to a new ReflectionBasedContainer hands over the container to the ServiceFactory (setter injection due to circular dependency) and finally returns the container &lt;?php declare(strict_types = 1); $config = include 'config.php'; $serviceFactory = new \\App\\Service\\ServiceFactory($config); $container = new \\Prooph\\EventMachine\\Container\\ReflectionBasedContainer( $serviceFactory, [ \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_STORE =&gt; \\Prooph\\EventStore\\EventStore::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_PROJECTION_MANAGER =&gt; \\Prooph\\EventStore\\Projection\\ProjectionManager::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_COMMAND_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\CommandBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\EventBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_QUERY_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\QueryBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_DOCUMENT_STORE =&gt; \\Prooph\\EventMachine\\Persistence\\DocumentStore::class, ] ); $serviceFactory-&gt;setContainer($container); return $container; Note: The container is passed to the service factory because the factory needs to pass it to Event Machine as soon as Event Machine is requested for the first time."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/production_optimization.html#3-1-3","title":"Optimize For Production","content":"Work in ProgressThe Description phase configures Event Machine. Depending on the size of the application this can result in many method calls which are known to be slow. During development that's not a problem but in production you don't want to do that on every request. Between two deployments code does not change and therefor the configuration does not change. We can safely cache it and respond faster to requests."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2","title":"Event Machine Descriptions","content":"In the previous chapter \"Set Up\" we already learned that Event Machine loads EventMachineDescriptions and passes itself as the only argument to a static describe method.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; interface EventMachineDescription { public static function describe(EventMachine $eventMachine): void; } Descriptions need to be loaded before EventMachine::initialize() is called.In the skeleton descriptions are listed in config\/autoload\/global.php and this list is read by the event machine factory method of the ServiceFactory:public function eventMachine(): EventMachine { $this-&gt;assertContainerIsset(); return $this-&gt;makeSingleton(EventMachine::class, function () { $eventMachine = new EventMachine(); \/\/Load descriptions here or add them to config\/autoload\/global.php foreach ($this-&gt;config-&gt;arrayValue('event_machine.descriptions') as $desc) { $eventMachine-&gt;load($desc); } $containerChain = new ContainerChain( $this-&gt;container, new EventMachineContainer($eventMachine) ); $eventMachine-&gt;initialize($containerChain); return $eventMachine; }); } Organising Descriptions: If you followed the tutorial, you already know that you can avoid code duplication and typing errors with a few simple tricks. Clever combinations of class and constant names can provide readable code without much effort. The skeleton ships with default Event Machine Descriptions to support you with that idea. You can find them in src\/Api"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-1","title":"Registration API","content":"Event Machine provides various registration methods. Those methods can only be called during description phase (see \"Set Up\" chapter for details about bootstrap phases). Here is an overview of available methods:&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; \/\/... final class EventMachine implements MessageDispatcher, AggregateStateStore { \/\/... \/** * Add a command message to the system along with its payload schema *\/ public function registerCommand(string $commandName, ObjectType $schema): self { \/\/... } \/** * Add an event message to the system along with its payload schema *\/ public function registerEvent(string $eventName, ObjectType $schema): self { \/\/... } \/** * Add a query message to the system along with its payload schema *\/ public function registerQuery(string $queryName, ObjectType $payloadSchema = null): QueryDescription { \/\/... } \/** * Add a data type to the system along with its json schema *\/ public function registerType(string $nameOrImmutableRecordClass, ObjectType $schema = null): void { \/\/... } \/** * Add an enum type to the system along with its json schema *\/ public function registerEnumType(string $typeName, EnumType $schema): void { \/\/... } \/** * Service id or instance of a CommandPreProcessor invoked before command is dispatched * * @param string $commandName * @param string | CommandPreProcessor $preProcessor *\/ public function preProcess(string $commandName, $preProcessor): self { \/\/... } \/** * Describe handling of a command using returned CommandProcessorDescription *\/ public function process(string $commandName): CommandProcessorDescription { \/\/... } \/** * Service id or callable event listener invoked after event is written to event stream * * @param string $eventName * @param string | callable $listener *\/ public function on(string $eventName, $listener): self { \/\/... } \/** * Describe a projection by using returned ProjectionDescription *\/ public function watch(Stream $stream): ProjectionDescription { \/\/... } \/\/... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-2","title":"Message Payload Schema","content":"Messages are like HTTP requests, but they are protocol agnostic. For HTTP requests\/responses PHP-FIG has defined a standard known as PSR-7. Event Machine messages on the other hand are prooph\/common messages.Like HTTP requests messages should be validated before doing anything with them. It can become a time consuming task to write validation logic for each message by hand. Hence, Event Machine has a built-in way to validate messages using Json Schema Draft 6. You do this using JsonSchema wrapper objects provided by Event Machine. Those objects are simple to use and drastically improve readability of the code.Again the command registration example from the previous chapter:$eventMachine-&gt;registerCommand( self::REGISTER_USER, JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); This code speaks for itself, doesn't it? It is beautiful and clean (IMHO) and once you're used to it you can add new messages to the system in less than 30 seconds. The chapter about \"Json Schema\" covers all the details. Make sure to check it out.A nice side effect of this approach is out-of-the-box Swagger UI support. Learn more about it in the \"Swagger UI\" chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-3","title":"Command Registration","content":"Event Machine needs to know which commands can be processed by the system. Therefor, you have to register them before defining processing logic.Software developed with Event Machine follows a Command-Query-Responsibility-Segregation (short CQRS) approach. Commands are used to trigger state changes without returning modified state and queries are used to request current state without modifying it.You're ask to tell Event Machine a few details about available commands. Each command should have a unique name and a payload schema. It is recommended to add a context as prefix in front of each command name. Let's take an example from the tutorial but add a context to the command name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const CMD_CXT = 'BuildingMgmt.'; const ADD_BUILDING = self::CMD_CXT.'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string()-&gt;withMinLength(2) ] ) ); } } Event Machine makes no assumptions about the format of the name. A common approach is to use a dot notation to separate context from message name e.g. BuildingMgmt.AddBuilding. Using dot notation has the advantage that message broker like RabbitMQ can use it for routing."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-4","title":"Command Processing","content":"Once Event Machine knows about a command you can register processing logic for it. Commands are processed by aggregate functions. Think of an aggregate as a process with multiple steps. Each step is triggered by a command and there is only one active step for a specific process aka. aggregate at the same time.In Event Machine aggregate functions are stateless. You can use plain PHP functions or classes with static public methods.Before we dive deeper into aggregate functions, let's have a look at how commands are processed. The following gif shows the power of Event Machine Descriptions especially CommandProcessingDescription. A fluent interface mixed with clever class and constant naming + modern IDE support (PHPStorm in this case) can assist you while putting together the pieces. You need to remember less which frees your mind to reason more about the logic you're developing. This results in a higher quality business logic, written in a shorter time. Try it yourself. It's actually a lot of fun to work with Event Machine.Keep an eye on the array callable syntax: [ShoppingCart::class, 'addItem']. PHPStorm provides code completion for it and respects it while renaming methods and classes. That's an awesome feature and makes the syntax save to use.Event Machine Descriptions keep glue code outside of the core business logic. This reduces \"noise\" in the core and creates a central overview for navigation through the code.Details about the various Description types can be found in their respective chapters like \"aggregates\", \"event listeners\" and \"projections\"."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3","title":"Aggregates","content":" Event Sourced Aggregates are Domain-Driven Aggregates, representing a unit of consistency. They protect invariants. This basically means that an aggregate makes sure that it can transition to a new state. Different business rules can permit or prevent state transitions, and the aggregate has to enforce these business rules. Source: http:\/\/docs.getprooph.org\/tutorial\/event_sourcing_basics.html#1-3-3When reading the definition above one immediately thinks of an object with internal state and methods to change that state. It's because we are used to work with object oriented programming. In Event Machine (and prooph\/micro as well) we stick to the same basic definition of an aggregate but apply a functional approach. This means that we use pure functions and immutable state in favour of mutable objects."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-1","title":"Functions vs. Objects","content":"Why functions, not objects?I'm glad you asked! Well, there is nothing wrong with using CQRS &amp; Event Sourcing in an object oriented fashion. But it turned out that the idea of a functional core plays well with Event Sourcing. If you look at the core ideas of Event Sourcing you'll recognize that it is heavily based on functional patterns: immutable events, append-only streams, left fold of past events to calculate current state, ...Business logic does not necessarily require OOP patterns, In fact, a functional core can avoid accidental complexity. Event Machine is one possible implementation that handles a lot of boilerplate for you. prooph\/micro is another - more lightweight - implementation, which means more freedom but also more design decisions.The good news is, that it is very easy to migrate from Event Machine to prooph\/micro. You can start with the simplicity of Event Machine and focus on model exploration. Once you have a working model but you need fine-grained scalability options you can switch to prooph\/micro and continue your journey.Event Machine grows with your application from prototype to MVP up to a rock solid production system. And it is able to reduce boilerplate code to a bare minimum because of a few \"simple\" rules:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-2","title":"1. Pure Functions","content":"Given the same input an aggregate function will always produce the same result.Here is the simplest form of a pure aggregate function in Event Machine:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-2-1","title":"prooph\/micro style","content":"\/\/some_business_process.php declare(strict_types=1); Namespace Acme\\Model\\SomeBusinessProcess; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; const startProcess = '\\Acme\\SomeBusinessProcess\\startProcess'; function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/More functions .... "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-2-2","title":"Static method style","content":"\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } As you can see both approaches are very similar. The prooph\/micro style looks more functional and underlines the intention of the code whereby the static method approach plays nice together with a modern IDE and PHP's autoloader. We'll stick to the static method approach in the examples because this is the recommended style when working with Event Machine. But prooph\/micro style can be used, too!Back to the pure nature of both approaches. No matter how often you call the function as long as the input message payload does not change, the yielded event won't change, too.This property makes testing the function a breeze. You don't need mocks. You don't need heavy fixture setup. Just create the appropriate message, call the function and test against an expected event."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-3","title":"2. Stateless Functions","content":"No object, no internal state and therefor a much simpler business logic implementation, which is easy to test, refactor and maintain!But even if we use functions, we have to be careful to not fall into the trap of modifying state:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-3-1","title":"Evil Global Variable","content":"One way to break the rule with a function is by modifying global state.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; $evilState = new EvilState(); final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { global $evilState; $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } Never ever do this! Don't even think about it!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-3-2","title":"Evil Static Property","content":"Another way to break our stateless function:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { private static $evilState; public static function startProcess(Message $startProcess): \\Generator { self::$evilState = new EvilState(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(Message $continue): \\Generator { yield [Event::SOME_PROCESS_CONTINUED, self::$evilState-&gt;toArray()]; } \/\/more methods .... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-3-3","title":"Evil Static Local Variable","content":"That's also a very bad idea:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(Message $continue): \\Generator { static $evilCounter; if($evilCounter === null) { $evilCounter = 0; } yield [Event::SOME_PROCESS_CONTINUED, ['counter' =&gt; ++$evilCounter]]; } \/\/more methods .... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-3-4","title":"Evil Mutable State Passed As Argument","content":"Mutable state passed as an argument is probably the easiest way to break the stateless rule. Let's look at an evil example first and then we'll see how we can do better.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(EvilMutableState $evilState, Message $continue): \\Generator { $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_CONTINUED, ['state' =&gt; $evilState-&gt;toArray()]]; } \/\/more methods .... } Let's fight the evil!\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; use Acme\\Api\\Payload; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function whenProcessStarted(Message $processStarted): ImmutableState { return new ImmutableState(); } public static funcion continueProcess(ImmutableState $state, Message $continue): \\Generator { if($state-&gt;wantsToBurnStatelessApproach()) { yield [Event::STATE_MUTATION_BLOCKED, [Payload::ALTERNATIVE =&gt; $continue-&gt;get(Payload::ALTERNATIVE)]]; } } public static function whenStateMutationBlocked(ImmutableState $currentState, Message $stateMutationBlocked): ImmutableState { return $currentState-&gt;withAlternativeMutation($stateMutationBlocked-&gt;get(Payload::ALTERNATIVE)); } } Ok, we see two new functions here. Both start with when followed by an event name.Note: The naming is only a recommendation.Those when functions do not take commands as input and do not yield events, but instead take yielded events as input and return (note the difference to yield) ImmutableState. The second when function even takes ImmutableState as an argument and returns it.To be able to understand the alternative to mutable state we have to jump into the method withAlternativeMutation:declare(strict_types=1); Namespace Acme\\Model; final class ImmutableState { private $alternative; public function alternative(): ?string { return $this-&gt;alternative; } public function withAlternativeMutation(string $alternative): self { $copy = clone $this; $copy-&gt;alternative = $alternative; return $copy; } } This is how state of an immutable value object is changed. Instead of modifying internal state directly, the value object copies itself and modfies the copy instead.It works because visibility of properties and methods is defined on class level and not on instance level.Let's look at the effect with a unit test:declare(strict_types=1); Namespace AcmeTest\\Model; use Acme\\Api\\Event; use Acme\\Api\\Payload; use Acme\\Model\\SomeBusinessProcess; use Acme\\Model\\ImmutableState; use AcmeTest\\BaseTestCase; \/\/&lt;-- extends PHPUnit\\Framework\\TestCase + provides message factory use Prooph\\EventMachine\\Messaging\\Message; final class SomeBusinessProcessTest extends BaseTestCase { \/** * @test *\/ public function it_does_not_change_input_state() { $inputState = new ImmutableState(); $this-&gt;assertNull($inputState-&gt;alternative()); $event = $this-&gt;messageFactory()-&gt;createMessageFromArray( Event::STATE_MUTATION_BLOCKED, [ 'payload' =&gt; [ 'alternative' =&gt; 'modify and return copy' ] ] ); $outputState = SomeBusinessProcess::whenStateMutationBlocked( $inputState, $event ); $this-&gt;assertNull($inputState-&gt;alternative()); $this-&gt;assertSame( 'modify and return copy', $outputState-&gt;alternative() ); } } Working with immutable state avoids a whole bunch of silly and hidden errors. Method calls are predictable. You can harden the system With simple tests, pave the way for refactorings and keep velocity high. Event Machine also has an easy job. It does not need to care about state changes, because they are fully managed in userland code. This means, that you have full control. No object mapping layer required, no dirty state and no unit of work.The \"Immutable State\" chapter provides a lot of tips and tricks to rapidly create and work with immutable value objects."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-4","title":"3. Side-Effect Free Functions","content":"Modifying global state is one kind of side-effect, I\/O is another. I\/O is the short term for Input\/Output and includes things like reading from or writing to a database, accessing the filesystem or calling a remote service. It describes any operation that might fail due to unavailability of the target system. If a function (or method) performs a database query but the database is down, the function will behave different than in normal cases. Hence, the result of the function call is not predictable.Side-Effects make testing harder. Performing I\/O usually requires mocking and you have to test against more scenarios. That's a bad situation specifically for business logic tests. When testing business logic you should focus on its behaviour and only on that! Mixing I\/O into the game makes it difficult.If we must not query a database or call a remote service in aggregate functions, where do we do it then? Well, outside of the functional core. The following diagram illustrates that idea.The diagram shows three layers. The outermost layer is where I\/O happens. Event Machine acts as a middleware between I\/O layer and the functional core."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-5","title":"Read I\/O","content":"We can tell Event Machine to invoke a ContextProvider before invoking an aggregate function. That's the preferred way to perform read I\/O to query data needed by the aggregate.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine\\Aggregate; use Prooph\\EventMachine\\Messaging\\Message; interface ContextProvider { \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command); } Let's say we have a shopping cart aggregate that processes AddItem commands. The command payload only contains the itemId but we also need the price of the item to enable free shipping if a certain order sum is reached.Context Provider: uses a price finder to get item price from a database and sets up a free shipping policy with 40,- \u00e2\u0082\u00ac (4000 Cent) as minimum order sum.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use Prooph\\EventMachine\\Aggregate\\ContextProvider; use Prooph\\EventMachine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\Policy\\FreeShipping; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; final class AddItemContextProvider implements ContextProvider { \/** * @var PriceFinder *\/ private $priceFinder; \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command) { $itemId = ItemId::fromString($command-&gt;get(Payload::ITEM_ID)); $itemPrice = $this-&gt;priceFinder-&gt;findItemPrice($itemId); $item = Item::withIdAndPrice($itemId, $itemPrice); $freeShipping = FreeShipping::fromInt(4000); return AddItemContext::fromRecordData(['item' =&gt; $item, 'freeShipping' =&gt; $freeShipping]); } } Command Processing Description: AddItemContextProvider service id (FQCN) is passed to provideContext.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use ProophExample\\ContextProvider\\AddItemContextProvider; use ProophExample\\ContextProvider\\ShoppingCart; final class Aggregate implements EventMachineDescription { const SHOPPING_CART = 'ShoppingCart'; public static function describe(EventMachine $eventMachine): void { \/\/... $eventMachine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); } } Shopping Cart Aggregate: receives AddItemContext as third argument in the addItem function&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use Prooph\\EventMachine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Event; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; use ProophExample\\ContextProvider\\ShoppingCart\\State; final class ShoppingCart { \/\/... public static function addItem(State $cart, Message $addItem, AddItemContext $context): \\Generator { yield [Event::ITEM_ADDED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), Payload::ITEM =&gt; $context-&gt;item()-&gt;toArray(), ]]; if(!$cart-&gt;freeShipping()) { \/\/Temporarily add item. We can safely do this, because $cart is immutable $cart = $cart-&gt;withAddedItem($context-&gt;item()); if($context-&gt;freeShipping()-&gt;isFree($cart-&gt;orderSum())) { yield [Event::FREE_SHIPPING_ENABLED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), ]]; } } } public static function whenItemAdded(State $cart, Message $itemAdded): State { return $cart-&gt;withAddedItem(Item::fromArray($itemAdded-&gt;get(Payload::ITEM))); } public static function whenFreeShippingEnabled(State $cart, Message $freeShippingEnabled): State { return $cart-&gt;withFreeShippingEnabled(); } } Full example code can be found in the \"examples\/ContextProvider\" dir of the event-machine-docs repository on Github."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-6","title":"Write I\/O","content":"Event Machine appends all yielded events to the write model event stream. You don't need to care about that. Read model updates are performed by projections (see \"Projections\" chapter) and all other Write I\/O should happen in event listeners (see \"Event Listeners\" chapter).Aggregate functions should NEVER perform any write operation directly but only yield events to trigger Write I\/O in the outermost layer."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-7","title":"Aggregate Lifecycle","content":"If an aggregate is composed of pure functions and those functions work with immutable state only, does the aggregate have a lifecycle?Yes! An aggregate has a lifecycle. It is just not implemented as an object that changes internal state over time. But an aggregate is still a domain concept - a business process. Each aggregate has a unique id and yielded events should contain that id (otherwise Event Machine throws an exception) so that the events can be added to the event stream of the aggregate. An event stream can be seen as a timeline. It tracks all important facts about the aggregate.But how can Event Machine always pass the current state of an aggregate to the next function?It seems like aggregate state is magically passed to aggregate functions. But the mechanism used by Event Machine is relatively simple. It is best explained with our shopping cart example again.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) Event Machine gets two important information here. The first one is that the lifecycle of our ShoppingCart aggregate begins with a StartShoppingSession command. And the second is that a ShoppingCart is identified by its ShoppingCartId. All commands addressing the shopping cart should contain the ShoppingCartId and all events yielded by the aggregate should contain the same id.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) Given the information above, Event Machine knows that the aggregae function ShoppingCart::startShoppingSession() only takes a StartShoppingSession command as argument. Aggregate state doesn't exist at this time because it's the first command.&lt;?php \/\/... final class ShoppingCart { public static function startShoppingSession(Message $startShoppingSession): \\Generator { yield [Event::SHOPPING_SESSION_STARTED, [ Payload::SHOPPING_CART_ID =&gt; $startShoppingSession-&gt;get(Payload::SHOPPING_CART_ID), ]]; } \/\/... } Event Machine will append the yielded ShoppingSessionStarted event to its write model event stream. This event will mark the beginning of a new shopping cart lifecycle.Every yielded event should have a corresponding apply function. Event Machine takes care of that rule. It's the last part of every CommandProcessingDescription.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) -&gt;recordThat(Event::SHOPPING_SESSION_STARTED) -&gt;apply([ShoppingCart::class, 'whenShoppingSessionStarted']); A recordThat call should always be followed by an apply call. Obvousely, it's a mapping so that Event Machine knows which apply function to use. And because the entire description is bound to the command being processed, Event Machine knows again that ShoppingCart::whenShoppingSessionStarted is the first apply function and therefor does not take aggregate state as an argument. But the apply function should return the first immutable state derived from the first event.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function whenShoppingSessionStarted(Message $shoppingSessionStarted): State { return State::newSession(ShoppingCartId::fromString( $shoppingSessionStarted-&gt;get(Payload::SHOPPING_CART_ID) )); } } All subsequent aggregate functions (command handling and event applying functions) receive the current aggregate state as the first argument.The following diagram illustrates how Event Machine calculates current state with the help of the apply functions."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/aggregates.html#3-3-8","title":"RecordThat","content":"The CommandProcessingDescription defines two aliases for recordThat: andRecordThat and orRecordThat. You can use them when an aggregate function yields multiple events (andRecordThat) or different events depending on conditions (orRecordThat).Event Machine doesn't really care about which variant you use, but if an aggregate function yields an unknown event (no recordThat-&gt;apply pair defined) Event Machine will throw an exception.$eventMachine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); It's not required that all events are yielded each time. The main thing is that Event Machine knows about them all. In some situations an aggregate function does not want to yield any new event. In such a case you can yield null and return from the function.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function removeItem(State $cart, Message $removeItem): \\Generator { $item = Item::fromArray($removeItem-&gt;get(Payload::ITEM)); if(!$cart-&gt;hasItem($item)) { yield null; return; } yield [Event::ITEM_REMOVED, $removeItem-&gt;payload()]; } } Wrap UP: Aggregates in Event Machine are composed of pure functions and immutable state. Command Processing Descriptions tell Event Machine how the pieces fit together. This reduces boilerpate code and we can focus on the domain and avoid silly bugs that interrupt our model exploration.In the next chapter you'll learn how immutable value objects can be generated quickly."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/immutable_state.html#3-4","title":"Immutable State","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/document_store\/set_up.html#3-5-1","title":"Document Store","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/projections\/set_up.html#3-6-1","title":"Custom Projections","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1","title":"Future of Event Machine","content":"Written by Alexander Miertsch (@codeliner) - CEO prooph software GmbH - prooph core team - 2018-09-08You may have read the official announcement by Sascha (@prolic) about the future of prooph components. Together with Sascha we decided to stop working on prooph\/common, prooph\/event-sourcing, prooph\/service-bus and all related packages like the various message queue adapters.Event Machine makes use of the packages so one may ask if Event Machine is effected by this announcement as well? The short answer is:Yes it is effected but we continue to work on Event Machine.If you want to know the reasoning behind these decisions and what we plan to do (prooph software GmbH team), this post provides you with answers."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-1","title":"Dropping Event Sourcing","content":"I'd like to go into details about the prooph components decision first. I think it is important to understand the reasoning and it will give you a better idea of what you can expect from Event Machine in the future.As the author of the very first prooph components back in 2014 I'm involved in core development since the first commit. prooph\/common and prooph\/event-sourcing always had the problem that one needs to extend message classes and aggregate roots from prooph. You can use custom messages and aggregate root implementations but this is not an easy task within the current design of the components. It's a big issue because prooph never wanted to be a framework. Independent components have a very high priority for the core team. Prooph is meant to be used in enterprise applications which should not be coupled to a framework.With a completely new event store implementation in the pipeline we revisited the problem. And because more teams use prooph in production, we receive requests from the community to provide better ways for custom messages as well as project specific needs for message serialization and such things.Now we could try to support all those concerns by adding more and more possibilities to tweak prooph, but this has a high price: complexity Even with the current design of prooph components one has a hard time to get started. A reason why Event Machine exists. If we would add more configuration options and whatnot, it would get worse.Back in the days, I started working on prooph because CQRS and Event Sourcing is a fascinating approach and can inspire you to solve problems in a completely different way. It needs some time and practice to get it right. Hence, battle-tested open source components might help developers to learn it without making the same mistakes. This still holds true, but can be limited to a proper event store implementation (including at-least-once message delivery for projections). We believe that a good event sourcing tutorial together with blueprints for event sourced aggregates and their repositories and a rock-solid prooph\/event-store available as open source is the better approach for the prooph community. New developers get a recipe to get started and can rely on a high quality event store implementation. If the provided event sourcing blueprint doesn't fit a use case it can easily be adopted because the team owns the event sourcing code as well as the repository implementation that talks to prooph\/event-store."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-2","title":"Dropping Service Bus","content":"Dropping development of prooph\/service-bus has other reasons. The component is designed to run in a modular application - think of ZF2 MVC or Symfony bundles. Since 2014 things have changed. The Zend Framework team promotes usage of zend expressive. Symfony made it easier to develop bundle-less applications. That said, nowadays both major frameworks advocate smaller application size with less layers and less complexity.Prooph components do the same with prooph\/micro, which doesn't use prooph\/service-bus. A software service bus introduces an additional layer. This is especially useful in a modularized monolithic application. If you don't use modules, you don't need a software bus or at least nothing with the complexity of prooph\/service-bus. For our daily work we no longer need prooph\/service-bus and that's true for Sascha (he is not working for prooph software), too.Hence, we decided together that if one needs a software message bus they have a lot of similar choices today. We don't need to spend our time on maintaining yet another solution.If I could buy time with money, I'd do it and all prooph components would have a \"buy me a minute\" donation button. But you cannot buy time (yet?), therefor we need to be very careful with it. Working on open source is a great experience especially within the prooph community. On the other hand it reduces available time a lot and always competes with family and friends time as well as payed work. Many big open source projects are baked by companies with even bigger budgets, but that's a different league. The prooph community is awesome. Join the improoph chat and you'll know what I mean. But we don't have core developers who get payed to maintain prooph. It's more or less all based on community work.Not enough time, new software architecture approaches and the availability of other software message bus solutions are the reasons for dropping prooph\/service-bus support. It's still a great package, so this decision is not an easy one."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3","title":"Components vs Event Machine","content":"Now let's look at Event Machine. prooph\/event-sourcing and prooph\/service-bus are both used under the hood. The good news is, that you don't interact with them directly so we can easily replace the packages. But what about the reasons? Don't they apply for Event Machine as well?I'm going to answer for each:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-1","title":"Framework Dependency","content":"Event Machine is a rapid application development framework. You either use it as-is or don't use it at all. That's a big difference compared to prooph components and also the reason why Event Machine is not part of the prooph components family but only maintained by the prooph software team (different vendor, different copyright). My company is interested in future development because we need it for our daily work.Event Machine is a great way to explore the world of CQRS and Event Sourcing without learning all theory upfront and spending days on putting all the pieces together. It is also a great way to develop prototypes and smaller applications. If you practice Domain-Driven Design, you probably know the difference between core domain and supporting domain. You should also know that it is not a good idea to solve all software problems with high quality implementations but rather focus on the core domain and design the rest of the system in a way that it works and is maintainable without too much effort. Event Machine is best used in supporting domains. It can be used for prototypes of core domains but only if you design the core domain in a way that you can easily delete and replace parts of it.Having said this, Event Machine doesn't have the same problem like prooph\/event-sourcing. A service developed with Event Machine is coupled by design. You need to be aware of the coupling and decide upfront (or after prototype phase) if that is ok for the service or not."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-2","title":"Modules","content":"It is not recommended to develop a monolith with Event Machine. The concept works really nice within clear service boundaries. Therefor, Event Machine doesn't need a complex message bus. prooph\/service-bus was integrated because early versions of Event Machine were used as a workshop framework - a prooph components glue layer. Replacing the service-bus package with a simple message dispatcher implementation isn't problematic."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-3","title":"Available Time","content":"As I already said, we need Event Machine for our daily work so prooph software GmbH is interested in ongoing development. This is also true for the new prooph\/event-store implementation which will become the heart of Event Machine 2.0."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-4","title":"Competing Solutions","content":"I'm not aware of any PHP open source library\/framework that provides similar mechanisms like Event Machine does. prooph\/micro is based on the same idea of functional event sourced domain behaviour, but does not provide the same RAD mechanisms. In fact, prooph\/micro is suitable for core domains (once stable), but requires more design decisions and work. I'll discuss this in detail in a future post."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-4","title":"Event Machine Roadmap","content":"Our plan was to finish documentation first and add some more tests before releasing Event Machine v1.0. Due to the prooph components announcement the plan changed. v1.0 will be released soon. Several projects already use Event Machine and a stable release will ensure that those projects don't run into trouble when we start refactoring of Event Machine. Work on documentation will be paused. In fact, the Event Machine tutorial is all you need to get started. API documentation will cover more details, but this has to wait."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-4-1","title":"Next Steps","content":" Remove prooph\/common Replace prooph\/event-sourcing Replace prooph\/service-bus Move Disco Light to separate package Move document store to separate package Move immutable record logic to separate package Use new prooph\/event-store-client and support async mode Implement non-blocking root projection as a persistent subscription "}]