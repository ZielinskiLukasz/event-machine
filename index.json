[{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1","title":"About Event Machine","content":"prooph software Event Machine takes away all the boring, time consuming parts of event sourcing to speed up development of event sourced applications and increase the fun. It can be used for prototypes as well as full featured applications."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1","title":"Origin","content":"Event Machine was originally designed as a \"workshop framework\"."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1-1","title":"Beginner friendly","content":" The Dreyfus model distinguishes five levels of competence, from novice to mastery. At the absolute beginner level people execute tasks based on \u00e2\u0080\u009crigid adherence to taught rules or plans\u00e2\u0080\u009d. Beginners need recipes. They don\u00e2\u0080\u0099t need a list of parts, or a dozen different ways to do the same thing. Instead what works are step by step instructions that they can internalize. As they practice them over time they learn the reasoning behind them, and learn to deviate from them and improvise, but they first need to feel like they\u00e2\u0080\u0099re doing something. (source: https:\/\/lambdaisland.com\/blog\/25-05-2017-simple-and-happy-is-clojure-dying-and-what-has-ruby-got-to-do-with-it)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1-2","title":"Rapid Application Development","content":"It turned out that Event Machine is not only a very good CQRS and Event Sourcing learning framework but that the same concept can be used for rapid application development (RAD). RAD frameworks focus on developer happiness and coding speed. Both can be achieved by using conventions, which allows the framework to do a lot of work \"under the hood\" so that developers can focus on the important part: developing the application.Having said this, Event Machine can be compared with frameworks like Ruby on Rails or Laravel, but it also has a unique selling point. Instead of working with a CRUD based approach, Event Machine uses CQRS and Event Sourcing, leveraging prooph\/components under the hood. This enables interesting scenarios like starting a project with a lean and rapid development approach and switch to an enterprise approach later. With Event Machine you get separation of concerns from day one. You also get separated write and read models which can be scaled independent of each other. Finally, you get a full history of all state changes, so it is not only cheap to develop an application with Event Machine but it's also cheap to maintain that application in production."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-2","title":"Powered By","content":"Event Machine is maintained by the prooph software team. The source code of Event Machine is open sourced along with the API documentation and a Getting Started Tutorial. Prooph software offers commercial support and workshops for Event Machine as well as for the prooph components.If you are interested please get in touch"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-1","title":"Pros","content":" Default set up based on the rich features provided by prooph components Ready-to-use skeleton Less code needed Programmatic message routing extension points to inject custom logic Audit log from day one (no data loss) Replay functionality Projections based on domain events PSR friendly http message box OpenAPI v3 Swagger integration Message flow analyzer (work in progress) Event store HTTP API (work in progress) "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-2","title":"Cons","content":" Opinionated framework "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-3","title":"Conclusion","content":"Reading through the pros and cons you may ask yourself when and why you should use Event Machine instead of working only with prooph components. Here is a list of hints that may help you make a decision but please note that the right choice is highly dependent on the project, requirements and the team. You should definitely try the tutorial and build a prototype with Event Machine! (If you are interested, you can contact us for a guided workshop):"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-3-1","title":"You may want to use Event Machine if:","content":" You're new to the concepts of CQRS and Event Sourcing and want to learn them You want to try CQRS and Event Sourcing in a side project without spending too much time with the theory You hate boilerplate but have no time to develop your own Event Machine You want to make use of advanced tooling provided by prooph software that requires Event Machine You want to establish a service-oriented architecture rather than building a monolithic system Your project is in an early stage and you need to try out different ideas or deliver features very fast You're practicing Domain-Driven Design and the service you're building belongs to a supporting sub domain You don't want to fight your framework but get the most out of it You're using a modern JavaScript framework in the frontend and need an API-only backend Note: Even if Event Machine is opinionated it is designed to support loose coupling between different parts of an application. This means that if you start a project using Event Machine but it gets in your way later you can get rid of it step by step (continuous refactoring)."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1","title":"Introduction","content":"Event Machine is a rapid application development (RAD) framework so let us jump directly into the practical part of the tutorial. Event Machine basic concepts will be explained throughout the tutorial. Once finished, you should be able to start with your own project. The API docs will help you along the way."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-1","title":"Workshops And Commercial Support","content":"Our team can help you to take the first steps and work out a solid foundation for your project based on the power and speed offered by Event Machine. If you're interested in workshops or commercial support, get in touch."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-2","title":"Tutorial Domain","content":"We will build a backend for a small application where you can register buildings and then check in and check out users in the buildings. The backend will expose a messagebox endpoint that excepts commands and queries. Each time a user is checked in or checked out we get a notification via a websocket connection.Credits: The tutorial domain is the same as the one used by Marco Pivetta in his CQRS and Event Sourcing Workshops."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3","title":"Application set up","content":"Please make sure you have Docker and Docker Compose installed.Note: Docker is THE ONLY supported set up at the moment. If you don't want to install docker you need PHP 7.1+ and Postgres 9.4+."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-1","title":"Clone Event Machine Skeleton","content":"Change into your working directory and use composer to create a new project based on the event machine skeleton using prooph-em-buildings as project name.$ docker run --rm -it -v $(pwd):\/app prooph\/composer:7.1 create-project proophsoftware\/event-machine-skeleton prooph-em-buildings Change into the newly created project dir prooph-em-buildings, start the docker containers and run the set up script for the event store.$ cd prooph-em-buildings $ sudo chown -R $(id -u -n):$(id -g -n) . $ docker-compose up -d $ docker-compose run php php scripts\/create_event_stream.php The last command should output done. otherwise it will throw an exception."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-1","title":"Database","content":"Verify database set up by connecting to the Postgres database using:host: localhost port: 5432 dbname: event_machine user: postgres pwd: Note: Credentials are defined in app.env and can be changed there.You should see three tables: event_streams, projections and _&lt;sha1&gt;. The latter is a table created by prooph\/event-store. It will contain all domain events."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-2","title":"Webserver","content":"Head over to http:\/\/localhost:8080 to check if the containers are up and running. You should see a \"It works\" message."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-3","title":"Swagger UI","content":"By default Event Machine exposes commands (we will learn more about them in a minute), events and queries via a message box endpoint. We can use Swagger UI to interact with the backend.The Event Machine skeleton ships with a ready to use Swagger UI. Open http:\/\/localhost:8080\/swagger\/index.html in your browser and try the built-in HealthCheck query.You should get a JSON response similar to that one:{ \"system\": true } If everything works correctly we are ready to implement our first use case: Add a buildingNote: If something is not working as expected (now or later in the tutorial) please check the trouble shooting section of the event-machine-skeleton README first."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2","title":"Part I - Add A Building","content":"We're going to add the first action to our buildings application. In a CQRS system, such as Event Machine, operations and processes are triggered by messages. Those messages can have three different types and define the API of the application. In the first part of the tutorial we learn the first message type: command."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-1","title":"API","content":"The Event Machine skeleton includes an API folder (src\/Api) that contains a predefined set of EventMachineDescription classes. We will look at these descriptions step by step and start with src\/Api\/Command.php:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Command implements EventMachineDescription { \/** * Define command names using constants * * @example * * const REGISTER_USER = 'RegisterUser'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Describe commands of the service and corresponding payload schema (used for input validation) } } The Command description is used to group all commands of our application into one file and add semantic meaning to our code. Replace the comment with a real constant const ADD_BUILDING = 'AddBuilding'; and register the command in the describe method.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } Event Machine uses JSON Schema to describe messages. The advantage of JSON schema is that we can configure validation rules for our messages. Whenever Event Machine receives a message (command, event or query) it uses the defined JSON Schema for that message to validate the input. We configure it once and Event Machine takes care of the rest.Note: The skeleton defines the namespace App in composer.json and maps it to the src directory. You can change that for your own project, but you need to change the namespaces of the classes\/interfaces shipped with the skeleton which are located in the src directory (just a few helpers)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-2","title":"Descriptions","content":"Event Machine Descriptions are very important. They are called at \"compile time\" and used to configure Event Machine. Later in the tutorial we learn more about using Event Machine in production. In production mode the descriptions are only called once and cached to speed up bootstrapping."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-3","title":"Swagger Integration","content":"Switch to the Swagger UI and reload the schema (press explore button). Swagger UI should show a new command called AddBuilding in the commands section.Click on the \"Try it out\" button and execute the AddBuilding command with the this request body:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } { \"error\": { \"message\": \"CommandBus was not able to identify a CommandHandler for command AddBuilding\", \"details\": \"...\" } } Our command cannot be handled because a command handler is missing. In Event Machine commands can be routed directly to Aggregates. In part II of the the tutorial you'll learn more about pure aggregates.Sum up: Event Machine Descriptions allow you to easily describe the API of your application using messages. The messages get a unique name and their payload is described with JSON Schema which allow us to add validation rules. The messages and their schema are translated to an OpenAPI v3 Schema and we can use Swagger UI to interact with the backend service."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3","title":"Part II - The Building Aggregate","content":"In Event Machine we can take a short cut and skip command handlers. This is possible because Aggregates in Event Machine are stateless and pure. This means that they don't have internal state and also no dependencies.Simply put: they are just functionsEvent Machine can take over the boilerplate and we, as developers, can focus on the business logic. I'll explain in greater detail later, but first we want to see a pure aggregate function in action.Note: If you've worked with a CQRS framework before it is maybe confusing because normally a command is handled by a command handler (comparable to an application service that handles a domain action) and the command handler would load a business entity or \"DDD\" aggregate from a repository. We still use the aggregate concept but make use of a functional programming approach. It keeps the domain model lean and testable and allows some nice optimizations for a RAD infrastructure.Let's add the first aggregate called Building in a new Model folder:&lt;?php declare(strict_types=1); namespace App\\Model; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { \/\/yield domain events } } As you can see the Building class uses static methods. It does not extend from a base class and has no dependencies. We could also use plain PHP functions instead but unfortunately PHP does not provide function autoloading (yet), so we stick to static methods and group all methods of an aggregate in a class.Building::add() receives AddBuilding messages (of type command) and should perform the business logic needed to add a new building to our application. But instead of adding a new building directly we're ask to yield a domain event."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-1","title":"Domain Events","content":"Domain events are the second message type used by Event Machine. The domain model is event sourced, meaning it records all state changes in a series of domain events. These domain events are yielded by aggregate methods and stored in an event store managed by Event Machine. The series of events can then be used to calculate the current state of an aggregate. We will see that in action in a later part of the tutorial and get a better understanding of the technique when we add more use cases to the application.For now let's add the first domain event in src\/Api\/Event:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } It looks similar to the AddBuilding command but uses a past tense name. That is a very important difference. Commands tell the application what it should do and events represent facts that have happened."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-2","title":"Yielding Events","content":"Aggregate methods can yield null, one domain event or multiple domain events depending on the result of the executed business logic. If an aggregate method yields null it indicates that no important fact happened and no event needs to be recorded. In many cases an aggregate method will yield one event which is the fact caused by the corresponding command. But there is no one-to-one connection between commands and events. In some cases more than one event is needed to communicate important facts or an error event is yielded instead of the expected event (we'll see that later).For the first use case we simply yield a BuildingAdded domain event when Building::add() is called with a AddBuilding command.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } } The special array syntax for yielding events is a short cut used by Event Machine. It creates the event based on given event name and payload and stores it in the event stream."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-3","title":"Aggregate Description","content":"If we switch back to the Swagger UI and send the AddBuilding command again, Event Machine still complains about a missing command handler. We need to tell Event Machine about our new aggregate and that it is responsible for handling AddBuilding commands. We can do this in another Event Machine Description in src\/Api\/Aggregate.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED); } } The connection between command and aggregate is described in a very verbose and readable way. Our IDE can suggest the describing methods of Event Machine's fluent interface and it is easy to remember each step. process tells Event Machine that the following description is for the given command name. withNew\/withExisting tells Event Machine which aggregate handles the command and if the aggregate exists already or a new one should be created. identifiedBy tells Event Machine which message payload property should be used to identify the responsible aggregate. Every command sent to the aggregate and every event yielded by the aggregate should contain this property handle takes a callable argument which is the aggregate method responsible for handling the command defined in process. We use the callable array syntax of PHP which can be analyzed by modern IDEs like PHPStorm for auto completion and refactorings. recordThat tells Event Machine which event is yielded by the aggregate's command handling method. If we try again to send AddBuilding we get a new error:{ \"error\": { \"message\": \"No apply function specified for event: BuildingAdded\", \"details\": \"...\" } } Command handling works now but an apply function is missing. In part III of the tutorial you'll learn how to add such a function and why it is needed."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4","title":"Part III - Aggregate State","content":"In part II we took a closer look at pure aggregate functions (implemented as static class methods in PHP because of missing function autoloading capabilities). Pure functions don't have side effects and are stateless. This makes them easy to test and understand. But an aggregate without state? How can an aggregate protect invariants (its main purpose) without state?The aggregate needs a way \"to look back\". It needs to know what happened in the past according to its own lifecycle. Without its current state and without information about past changes the aggregate could only execute business logic and enforce business rules based on the given information of the current command passed to a handling function. In most cases this is not enough.The functional programming solution to that problem is to pass the current state (which is computed from the past events recorded by the aggregate) to each command handling function (except the one handling the first command). This means that aggregate behaviour (command handling functions) and aggregate state (a data structure of a certain type) are two different things and separated from each other. How this is implemented in Event Machine is shown in this part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4-1","title":"Applying Domain Events","content":"Aggregate state is computed by iterating over all recorded domain events of the aggregate history starting with the oldest event. Event Machine does not provide a generic way to compute current state, instead the aggregate should have an apply function for each recorded event. Those apply functions are often prefixed with when followed by the event name.Let's add such a function for our BuildingAdded domain event.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { \/\/@TODO: Return new state for the aggregate } } BuildingAdded communicates that a new lifecycle of a building was started (new building was added to our system), so the Building::whenBuilidngAdded() function has to return a new state object and does not receive a current state object as an argument (next when* function will receive one!).But what does the State object look like? Well, you can use whatever you want. Event Machine does not care about a particular implementation (see docs for details). However, Event Machine ships with a default implementation of an ImmutableRecord. We use that implementation in the tutorial, but it is your choice if you want to use it in your application, too.Create a State class in src\/Model\/Building (new directory):&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } } Note: You can use PHPStorm to generate the Getter-Methods. You only have to write the private properties and add the doc blocks with @var type hints. Then use PHPStorm's ability to add the Getter-Methods (ALT+EINF). By default PHPStorm sets a get* prefix for each method. However, immutable records don't have setter methods and don't work with the get* prefix. Just change the template in your PHPStorm config: Settings -&gt; Editor -&gt; File and Code Templates -&gt; PHP Getter Method to:\/** * @return ${TYPE_HINT} *\/ public ${STATIC} function ${FIELD_NAME}()#if(${RETURN_TYPE}): ${RETURN_TYPE}#else#end { #if (${STATIC} == \"static\") return self::$${FIELD_NAME}; #else return $this-&gt;${FIELD_NAME}; #end } Now we can return a new Building\\State from Building::whenBuilidngAdded().&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } } Finally, we have to tell Event Machine about that apply function to complete the AddBuilding use case description. In src\/Api\/Aggregate:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) \/\/Map recorded event to apply function -&gt;apply([Building::class, 'whenBuildingAdded']); } } We're done with the write model for the first use case. If you send the AddBuilding command again using Swagger UI:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } ... you should receive a [202] command accepted responseEvent Machine emphasizes a CQRS and Event Sourcing architecture. For commands this means that no data is returned. The write model has received and processed the command AddBuilding successfully but we don't know what the new application state looks like. We will use a query, which is the third message type, to get this data. Head over to tutorial part IV to learn more about queries and application state management using projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5","title":"Part IV - Projections and Queries","content":"In part III of the tutorial we successfully implemented the first write model use case: Add a new building. Connect to the Postgres database and check the event stream table _4228e4a00331b5d5e751db0481828e22a2c3c8ef. The table should contain the first domain event yielded by the Building aggregate and recorded by event machine. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 If you're wondering why the event stream table has a sha1 hashed name this is because by default prooph\/event-store uses that naming strategy to avoid database vendor specific character constraints. You can however configure a different naming strategy if you don't like it.The write model only needs an event stream to store information but the read side has a hard time querying it. As long as we only have a few events in the stream queries are simple and fast. But over time this table will grow and contain many different events. To stay flexible we need to separate the write side from the read side. And this is done using so called projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-1","title":"Registering Projections","content":"Projections in Event Machine make use of the projection feature shipped with prooph\/event-store. An important difference is that by default Event Machine uses a single long-running PHP process to manage those projections. This way processing order of events is always the same (FIFO). A disadvantage is that projections are slower because of the sequential processing.But don't worry: If projections become a bottleneck you can simply switch to plain prooph\/event-store projections and run them in parallel. The recommendation is to switch to that approach only if it is really needed. Deploying and coordinating multiple projection processes requires a good (project specific) strategy and tools.Ok enough theory. Let's get back to the beauty and simplicity of Event Machine. You can use a shortcut if aggregate state should be available as a read model. You only need one of the available EventMachine\\Persistence\\DocumentStore implementations. By default the skeleton uses proophsoftware\/postgres-document-store but you can also use proophsoftware\/mongo-document-store or implement your own. See Event Machine docs for details.We only need to register an aggregate projection in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { \/** * You can register aggregate and custom projections in event machine * * For custom projection you should define a unique projection name using a constant * * const USER_FRIENDS = 'UserFriends'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); } } That's it. If you look into the Postgres DB you should see a new table called em_ds_building_projection_0_1_0. And the table should contain one row with two columns id and doc with id being the buildingId and doc being the JSON representation of the Building\\State.Note: If you cannot see the table please check the troubleshooting section of event-machine-skeleton README.You can learn more about projections in the docs. For now it is enough to know how to register them. Let's complete the picture and query the projection table using Swagger UI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-2","title":"Query, Resolver and Return Type","content":"We already know that Event Machine uses JSON Schema to describe message types and define validation rules. For queries we can also register return types in Event Machine and those return types will appear in the Model section of the Swagger UI.Registering types is done in src\/Api\/Type:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; private static function healthCheck(): ObjectType { return JsonSchema::object([ 'system' =&gt; JsonSchema::boolean() ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); } } As you can see the HealthCheck type used by the HealthCheck query is already registered here. We simply add Building\\State as the second type and use the aggregate type as name for the building type.Note: Types are described using JSON Schema. Building\\State implements ImmutableRecord and therefore provides the method ImmutableRecord::__schema (provided by ImmutableRecordLogic trait) which returns a JSON Schema object.Note: Using aggregate state as return type for queries couples the write model with the read model. However, you can replace the return type definition at any time. So we can use the short cut in an early stage and switch to a decoupled version later.Next step is to register the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(\/* ??? *\/) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Queries are named like the \"things\" they return. This results in a clean and easy to use messagebox schema.Please note that the return type is a reference: JsonSchema::typeRef().Last but not least, the query needs to be handled by a so-called finder (prooph term).When the query is sent to the messagebox endpoint it is translated into a query message that is passed on to prooph's query bus. The query message is validated against the schema defined during query registration $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object(...)).Our first query has a required argument, buildingId, which should be a valid Uuid. An invalid uuid will fail when the query is parsed into a Event Machine message.Long story short, we need a finder, as described in the prooph docs: QueryBus: much the same as the command bus but the message handler is invoked with the query message and a React\\Promise\\Deferred that needs to be resolved by the message handler aka finder. Create a new class called BuildingFinder in a new directory Finder in src\/Infrastructure.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use React\\Promise\\Deferred; final class BuildingFinder { public function __invoke(Message $buildingQuery, Deferred $deferred): void { \/\/@TODO: resolve $deferred } } This is an invokable finder, as described in the prooph docs. It receives the query message as the first argument and a React\\Promise\\Deferred as the second argument. prooph's query bus can be used in an async, non-blocking I\/O runtime as well as a normal, blocking runtime, so the finder must resolve the deferred object instead of returning a result. We work with the Promise and Deferred objects provided by the ReactPHP library (unfortunately, we have no PSR for promises yet). Event Machine takes care of resolving promises returned by prooph's query bus.The finder needs to query the read model. While looking at projections we briefly discussed Event Machine's DocumentStore API. The finder can use it to access documents organized in collections. Let's see how that works.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { $buildingId = $buildingQuery-&gt;get('buildingId'); $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } } The implementation is self explanatory, but a few notes should be made.Every Event Machine message has a get and a getOrDefault method which are both short cuts to access keys of the message payload. The difference between the two is obvious. If the payload key is NOT set and you use get the message will throw an exception. If the payload key is NOT set and you use getOrDefault you get back the default passed as the second argument.The second note is about the collection name. It is injected at runtime rather than defined as a hardcoded string or constant. Do you remember the read model table name em_ds_building_projection_0_1_0? First of all, this is also a default naming strategy and can be changed. However, the interesting part here is the version number at the end of the name. This is the application version which you can pass to EventMachine::boostrap() (see docs for details). When deploying a new application version it is possible to rebuild all projection tables using the new version while the old projection tables remain active until load balancers are switched (Blue Green Deployment).Finally, we need to configure Event Machine's DI container to inject the dependencies into our new finder."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-3","title":"PSR-11 Container","content":"Event Machine can use any PSR-11 compatible container. By default it uses a very simple implementation included in the Event Machine package. The DI container is inspired by bitExpert\/disco but removes the need for annotations. Dependencies are managed in a single ServiceFactory class which is located in src\/Service.Just add the following method to the ServiceFactory:&lt;?php namespace App\\Service; \/\/New use statements use App\\Api\\Aggregate; use App\\Infrastructure\\Finder\\BuildingFinder; use Prooph\\EventMachine\\Projecting\\AggregateProjector; \/\/Other use statements use ... final class ServiceFactory { \/* ... *\/ public function setContainer(ContainerInterface $container): void { $this-&gt;container = $container; } \/\/Finders public function buildingFinder(): BuildingFinder \/\/&lt;-- Return type is used as service id { \/\/Service is treated as a singleton, DI returns the same instance on subsequent gets return $this-&gt;makeSingleton(BuildingFinder::class \/*&lt;-- again service id *\/, function () { return new BuildingFinder( \/\/We can use the AggregateProjector to generate correct collection name AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), \/\/&lt;-- Inside a closure we still have access to other methods Aggregate::BUILDING \/\/ of the ServiceFactory, like the getter for Event Machine itself ), $this-&gt;documentStore() \/\/ or the document store ); }); } \/* ... *\/ } And use BuildingFinder::class as the finder service id when registering the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; \/\/&lt;-- New use statement use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) \/\/&lt;-- Finder service id -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Ok! We should be able to query buildings by buildingId now. Switch to Swagger and reload the schema (press the \"explore\" button). The Documentation Explorer should show a new Query: Building. If we send that query with the buildingId used in AddBuilding:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } We get back:{ \"name\": \"Acme Headquarters\", \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } Awesome, isn't it?"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-4","title":"Optional Query Arguments","content":"Finders can also handle multiple queries. This is useful when multiple queries can be resolved by accessing the same read model collection. A second query for the BuildingFinder would be a query that lists all buildings or a subset filtered by name.Add the query to src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; \/\/&lt;-- New query, note the plural public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); \/\/New query $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], \/\/No required arguments for this query \/\/Optional argument name, is a nullable string ['name' =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) \/\/Resolve query with same finder ... -&gt;resolveWith(BuildingFinder::class) \/\/... but return an array of Building type -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } The refactored BuildingFinder looks like this:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get('buildingId')); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault('name', null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter('name', \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } BuildingFinder can resolve both queries by mapping the query name to an internal resolve* method. For the new Buildings query the finder makes use of DocumentStore\\Filters. The LikeFilter works the same way as a SQL like expression using % as a placeholder. AnyFilter matches any documents in the collection. There are many more filters available. Read more about filters in the docs.You can test the new query using Swagger. This is an example query with a name filter:{ \"payload\": { \"name\": \"Acme\" } } You can add some more buildings and play with the queries. Try to exchange the LikeFilter with a EqFilter for example. Or see what happens if you pass an empty string as name filter.In part VI we got back to the write model and learned how to work with process managers. But before we continue, we should clean up our code a bit. Part V tells you what we can improve."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6","title":"Part V - DRY","content":"You may have noticed that we use the static classes in src\/Api as a central place to define constants. At least we did that for message (Command, Event, Query) and aggregate names. We did not touch src\/Api\/Payload and src\/Api\/Schema yet.The idea behind those two classes is to group some common constants and static methods so that we don't have to repeat them over and over again. This makes it much easier to refactor the codebase later."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-1","title":"Payload","content":"In src\/Api\/Payload we simply define a constant for each possible message payload key. We've used two keys so far: buildingId and name so we should add them ...&lt;?php declare(strict_types=1); namespace App\\Api; class Payload { \/\/Predefined keys for query payloads, see App\\Api\\Schema::queryPagination() for further information const SKIP = 'skip'; const LIMIT = 'limit'; const BUILDING_ID = 'buildingId'; const NAME = 'name'; } ... and replace plain strings with the constants in our codebase:src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } src\/Infrastructure\/Finder\/BuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get(Payload::BUILDING_ID)); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault(Payload::NAME, null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter(Payload::NAME, \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-2","title":"Schema","content":"Schema definitions are another area where DRY (Don't Repeat Yourself) makes a lot of sense. A good practice is to define a schema for each payload key and reuse it when registering messages. Type references (JsonSchema::typeRef) should also be wrapped by a schema method. Open src\/Api\/Schema and add the static methods:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { public static function buildingId(): UuidType { return JsonSchema::uuid(); } public static function buildingName(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function buildingNameFilter(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function building(): TypeRef { return JsonSchema::typeRef(Aggregate::BUILDING); } public static function buildingList(): ArrayType { return JsonSchema::array(self::building()); } \/* ... *\/ } Doing this creates one place that gives us an overview of all domain specific schema definitions and we can simply change them if requirements change.Note: Even if we only use \"name\" in message payload for building names we use a more precise method name in Schema. A message defines the context so we can use a shorter payload key but the schema should be explicit.You can now replace all schema definitions.src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::building()); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(Schema::buildingNameFilter())] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::buildingList()); } } We're done with the refactoring and ready to add the next use case. Head over to part VI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7","title":"Part VI - Check in User","content":"The second use case of our Building Management system checks users into buildings. Users are identified by their name."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-1","title":"Command","content":"Let's add a new command for the use case in src\/Api\/Command:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerCommand( Command::CHECK_IN_USER, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } We can reuse Payload::NAME but assign a different schema so that we can change schema for a building name without influencing the schema of user name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-2","title":"Event","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); $eventMachine-&gt;registerEvent( self::USER_CHECKED_IN, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-3","title":"Aggregate","content":"Did you notice that we are getting faster? Once, you're used to Event Machine's API you can develop at the speed of light ;).A user can only check into an existing building. builidngId is part of the command payload and should reference a building in our system. For the command handling aggregate function this means that we also have state of the aggregate and Event Machine will pass that state as the first argument to the command handling function as well as to the event apply function:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } Building::checkInUser() is still a dumb function (we will change that in a minute) but Building::whenUserCheckedIn() contains an interesting detail. Building\\State is an immutable record. But we can add with* methods to it to modify state. You may know these with* methods from the PSR-7 standard. It is a common practice to prefix state changing methods of immutable objects with with. Those methods should return a new instance with the modified state rather than changing its own state. Here is the implementation of Building\\State::withCheckedInUser(string $username): Building\\State:&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use App\\Api\\Schema; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @var array *\/ private $users = []; public static function __schema(): Type { return self::generateSchemaFromPropTypeMap([ 'users' =&gt; JsonSchema::TYPE_STRING ]); } \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } \/** * @return array *\/ public function users(): array { return array_keys($this-&gt;users); } public function withCheckedInUser(string $username): State { $copy = clone $this; $copy-&gt;users[$username] = null; return $copy; } public function isUserCheckedIn(string $username): bool { return array_key_exists($username, $this-&gt;users); } } We can make a copy of the record and modify that. The original record is not modified, and we return the copy to satisfy the immutable record contract.Besides withCheckedInUser we've added a new property, users, and a getter for it. We also overrode the __schema method of ImmutableRecordLogic to pass a type hint to ImmutableRecordLogic::generateSchemaFromPropTypeMap(). Unfortunately, we can only type hint for array in PHP, and it is not possible to use return type hints like string[]. Hopefully this will change in a future version of PHP, but, for now, we have to live with the workaround and give ImmutableRecordLogic a hint that array items of the users property are of type string.Note: ImmutableRecordLogic derives type information by inspecting return types of getter methods named like their corresponding private properties.Internally, user names are used as the array index so the same user cannot appear twice in the list. With Building\\State::isUserCheckedIn(string $username): bool we can look up if the given user is currently in the building. Building\\State::users() on the other hand returns a list of user names like defined in the __schema. Internal state is used for fast look ups and external schema is used for the read model. More on that in a minute."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-4","title":"Command Processing","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']); } } Pretty much the same command processing description but with command, event and function names based on the new use case. An important difference is that we use -&gt;withExisting instead of -&gt;withNew. As already stated this tells Event Machine to look up an existing Building using the buildingId from the CheckInUser command.The following command should check in John into the Acme Headquarters.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Looks good! And what does the response of the Buildings query look now? If you inspect the schema of the query and click on the Building return type you'll notice the new property users.{ \"payload\": { \"name\": \"Acme\" } } Response[ { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } ] Great! We get back the list of users checked into the building."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-5","title":"Protect Invariants","content":"One of the main tasks of an aggregate is to protect invariants. A user cannot check in twice. The Building aggregate should enforce the business rule:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { throw new \\DomainException(sprintf( \"User %s is already in the building\", $checkInUser-&gt;get(Payload::NAME) )); } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } The command handling function can make use of $state passed to it as this will always be the current state of the aggregate. If the given user is already checked in we throw an exception to stop command processing.Let's try it:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Response:{ \"error\": { \"message\": \"User John is already in the building\", \"details\": \"...\" } } Throwing an exception is the simplest way to protect invariants. However, with event sourcing we have a different (and in most cases) better option. This will be covered in the next part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8","title":"Part VII - The Unhappy Path","content":"Developers tend to work out the happy path of a feature only and throw exceptions in every unknown situation. This behaviour is often caused by bad project management. Developers get domain knowledge from Jira tickets written by a product owner (Jira is used here as a synonym for any ticket system used in an agile process) instead of talking to domain experts face-to-face. Most tickets don't include unhappy paths until they happen and find their way back to the developer as a bug ticket.Is this really the best way to deal with unexpected scenarios? Wouldn't it be better to prepare for the unhappy paths as well? Sure, it takes more time upfront but saves a lot of time later when the application runs in production and can deal with failure scenarios in a sane way.Our Building aggregate does a bad job with regards to failure handling. Imagine a user is already in a building and tries to check in again. What does that mean in the real world? First of all it is not possible to be in and out of a building at the same time. So either a hacker has stolen the identity or system state is broken for whatever reason. Deciding if entrance to the building is blocked or not should be made by the business. And regardless of the decision it is always interesting to have an event in the event stream about the double check in. This makes monitoring much simpler than scanning error logs.We've talked to the domain experts and they want us to notify security in case of a DoubleCheckIn. With Event Machine this is as simple as throwing an exception ;)We need an event to record a DoubleCheckIn:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerEvent( self::DOUBLE_CHECK_IN_DETECTED, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } Now that we have the event we can replace the exception and yield a DoubleCheckInDetected event instead:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { yield [Event::DOUBLE_CHECK_IN_DETECTED, $checkInUser-&gt;payload()]; return; \/\/&lt;-- Note: we need to return, otherwise UserCheckedIn would be yielded, too } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } public static function whenDoubleCheckInDetected(Building\\State $state, Message $event): Building\\State { \/\/No state change required, simply return current state return $state; } } We need to tell Event Machine that Building::checkInUser() yields DoubleCheckInDetected in some situations:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([Building::class, 'whenDoubleCheckInDetected']); } } Try to check John in again:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Instead of an error we get a 202 command accepted response.But when we look at the event stream (table _4228e4a00331b5d5e751db0481828e22a2c3c8ef) we see a DoubleCheckInDetected event. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 2 0ee8d2fb-... UserCheckedIn {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"1ce0e46d-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 2} 2018-02-16 21:37:55.131122 3 4f6a8429-... DoubleCheckInDetected {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"c347dd85-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 3} 2018-02-16 23:03:59.739666 "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-1","title":"Process Manager","content":"To complete the user story we have to notify security. The security team uses a dedicated monitoring application that can receive arbitrary notification messages. To communicate with that external system we can use a so-called process manager or policy. Maybe you're more familiar with the term event listener but be careful to not mix it with event listeners known from web frameworks like Symfony or Zend. Listeners in Event Machine react to domain events and trigger follow up commands for actions, like sending emails or interacting with external systems.We can simulate the security monitoring system with a small JS app shipped with the event-machine-skeleton. Open http:\/\/localhost:8080\/ws.html in your browser.Note: If the app shows a connection error then try to log into the rabbit mgmt console first: https:\/\/localhost:8081. Accept the self-signed certificate and login with usr: prooph pwd: prooph. If you're logged in switch back to http:\/\/localhost:8080\/ws.html and reload the page.If the app says Status: Connected to websocket: ui-queue it is ready to receive messages from Event Machine.In src\/Service\/ServiceFactory you can find a factory method for a App\\Infrastructure\\ServiceBus\\UiExchange. It's a default domain event listener shipped with the skeleton that can be used to push events on a RabbitMQ ui-exchange. The exchange is preconfigured (you can see that in the rabbit mgmt UI) and the JS app connects to a corresponding ui-queue.In src\/Api\/Listener we can put together the pieces:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\ServiceBus\\UiExchange; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Listener implements EventMachineDescription { public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;on(Event::DOUBLE_CHECK_IN_DETECTED, UiExchange::class); } } Whenever a DoubleCheckInDetected event is recorded and written to the stream Event Machine invokes the UiExchange listener that takes the event and pushes it to rabbit.Try to check John in again, while keeping an eye on the monitoring app http:\/\/localhost:8080\/ws.html.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } ]"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-2","title":"The End","content":"Congratulations! You've mastered the Event Machine tutorial. There are two bonus parts available to learn more about custom projections and testing with Event Machine. The current implementation is available as a demo branch of proophsoftware\/event-machine-skeleton. There is a second branch called demo-oop available that contains a similar implementation, but the Building aggregate is designed using an object oriented approach rather than the functional approach shown in the tutorial. If you like that OOP style more you can of course use that.Functional programming fans might dislike the static class methods. You can also use real functions instead of static class methods, but you have to configure composer to always require the files containing your functions. It's up to you.The Event Machine API docs contain a lot more details. Last but not least, a reminder that the prooph software team offers commercial project support and workshops for Event Machine and the prooph components.Our workshops include Event Storming sessions and guidance on how to turn the results into working prototypes using Event Machine. We can also show and discuss framework integrations. Event Machine can easily be integrated with Symfony, Laravel and other PHP web frameworks. The skeleton is based on Zend Strategility so you can handle http related tasks, like authentication, using PSR-15 middleware. But again, other web frameworks play nicely with Event Machine, too.If you are interested please get in touch!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9","title":"Bonus I - Custom Projection","content":"The product owner comes along with a new feature request. They need a way to look up the building a user is checked into, if any."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-1","title":"Exercise","content":"Before we implement that feature you're asked to implement the check out user use case. Add a command CheckOutUser and an event UserCheckedOut. Let the Building aggregate and Building\\State handle the command and make sure that DoubleCheckOutDetected can also be monitored using the monitoring UI.Does it work? Great!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-2","title":"Implement a Projector","content":"What we need is a list of usernames and a reference to the building they are checked into. A custom projection can keep track of UserCheckedIn and UserCheckedOut events to keep the list up-to-date.To do that we need our own Prooph\\EventMachine\\Projecting\\Projector implementation. Create a new class called UserBuildingList in src\/Infrastructure\/Projector with the following content:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; use Prooph\\EventMachine\\Projecting\\Projector; final class UserBuildingList implements Projector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $appVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection($this-&gt;generateCollectionName($appVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( $this-&gt;generateCollectionName($appVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $appVersion, string $projectionName, Message $event): void { $collection = $this-&gt;generateCollectionName($appVersion, $projectionName); switch ($event-&gt;messageName()) { case Event::USER_CHECKED_IN: $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;get(Payload::NAME), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;get(Payload::BUILDING_ID)] ); break; case Event::USER_CHECKED_OUT: $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;get(Payload::NAME)); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection($this-&gt;generateCollectionName($appVersion, $projectionName)); } private function generateCollectionName(string $appVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection, too return AggregateProjector::generateCollectionName($appVersion, $projectionName); } } Make the projector available as a service in src\/Service\/ServiceFactory:&lt;?php namespace App\\Service; use App\\Infrastructure\\Projector\\UserBuildingList; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function buildingFinder(): BuildingFinder { return $this-&gt;makeSingleton(BuildingFinder::class, function () { return new BuildingFinder( AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ), $this-&gt;documentStore() ); }); } \/\/Projectors public function userBuildingListProjector(): UserBuildingList { return $this-&gt;makeSingleton(UserBuildingList::class, function () { return new UserBuildingList($this-&gt;documentStore()); }); } \/* ... *\/ } And describe the projector in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Projector\\UserBuildingList; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { const USER_BUILDING_LIST = 'user_building_list'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;with(self::USER_BUILDING_LIST, UserBuildingList::class) -&gt;filterEvents([ Event::USER_CHECKED_IN, Event::USER_CHECKED_OUT, ]); } } If you look at the Postgres DB you should see a new table called em_ds_user_building_list_0_1_0 but the table is empty. We can reset the long-running projection process used by Event Machine and therefor recreate all read models. This will fill the new read model with data from the past. That's cool, isn't it?Run the command docker-compose run php php bin\/reset.php in the project directory and check the table again.Here we go: id doc John {\"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\"} "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-3","title":"Look up","content":"We can add a new query, finder and corresponding type definitions to complete the look up feature.src\/Api\/Type&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const USER_BUILDING = 'UserBuilding'; \/\/&lt;-- new type \/* ... *\/ private static function userBuilding(): ObjectType { return JsonSchema::object([ 'user' =&gt; Schema::username(), 'building' =&gt; Schema::building()-&gt;asNullable(), \/\/&lt;-- type ref to building, can be null ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); $eventMachine-&gt;registerType(self::USER_BUILDING, self::userBuilding()); \/\/&lt;-- type registration } } src\/Api\/Schema&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function userBuilding(): TypeRef { return JsonSchema::typeRef(Type::USER_BUILDING); } \/* ... *\/ } src\/Infrastructure\/Finder\/UserBuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class UserBuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function __invoke(Message $query, Deferred $deferred): void { $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;get(Payload::NAME) ); if(!$userBuilding) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; $building ]); return; } } src\/Service\/ServiceFactory&lt;?php namespace App\\Service; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function userBuildingFidner(): UserBuildingFinder { return $this-&gt;makeSingleton(UserBuildingFinder::class, function () { return new UserBuildingFinder( $this-&gt;documentStore(), AggregateProjector::generateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Projection::USER_BUILDING_LIST ), AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ) ); }); } \/* ... *\/ } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ \/* ... *\/ const USER_BUILDING = 'UserBuilding'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery( self::USER_BUILDING, JsonSchema::object(['name' =&gt; Schema::username()]) ) -&gt;resolveWith(UserBuildingFinder::class) -&gt;setReturnType(Schema::userBuilding()); } } Swagger - UserBuilding query{ \"payload\": { \"name\": \"John\" } } Response{ \"user\": \"John\", \"building\": { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } An hour of work (with a bit more practice even less) and we are ready to ship the new feature! Rapid application development at its best! RAD is ok, but please don't skip testing! In the second bonus part of the tutorial we'll learn that Event Machine makes it easy to run integration tests. Don't miss it!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10","title":"Bonus II - Unit and Integration Tests","content":"Unit testing the different parts of the application is easy. In most cases we have single purpose classes and functions that can be tested without mocking."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-1","title":"Testing Aggregate functions","content":"Aggregate functions are pure which makes them easy to test. event-machine-skeleton provides some test helpers in tests\/BaseTestCase.php, so, if you extend from that base class, you're ready to go. Add a folder Model in tests and a class BuildingTest with the following content:&lt;?php declare(strict_types=1); namespace AppTest\\Model; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use AppTest\\BaseTestCase; use Ramsey\\Uuid\\Uuid; use App\\Model\\Building; class BuildingTest extends BaseTestCase { private $buildingId; private $buildingName; private $username; protected function setUp() { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } \/** * @test *\/ public function it_detects_double_check_in() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); $state = $state-&gt;withCheckedInUser($this-&gt;username); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::DOUBLE_CHECK_IN_DETECTED, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); \/\/And the other way round, list should not contain event with given name $this-&gt;assertNotRecordedEvent(Event::USER_CHECKED_IN, $events); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-2","title":"Testing Projectors","content":"Testing projectors is also easy when they use the DocumentStore API to manage projections. Event Machine ships with an InMemoryDocumentStore implementation that works great in test cases. Here is an example:tests\/Infrastructure\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\Projector\\UserBuildingList; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; final class UserBuildingListTest extends BaseTestCase { const APP_VERSION = '0.1.0'; const PROJECTION_NAME = 'user_building_list'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var DocumentStore *\/ private $documentStore; \/** * @var UserBuildingList *\/ private $projector; protected function setUp() { parent::setUp(); $this-&gt;documentStore = new DocumentStore\\InMemoryDocumentStore(); $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun(self::APP_VERSION, self::PROJECTION_NAME); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = AggregateProjector::generateCollectionName(self::APP_VERSION, self::PROJECTION_NAME); $johnCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $janeCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = $this-&gt;message(Event::USER_CHECKED_OUT, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedOut); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-3","title":"Testing Finders","content":"Finders can be tested in the same manner as projectors, using the InMemoryDocumentStore with prefilled data. I will leave implementing these tests as an exercise for you ;)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-4","title":"Integration Tests","content":"If you want to test the \"whole thing\" then you can make use of Event Machine's test mode. In test mode Event Machine is set up with an InMemoryEventStore and an InMemoryDocumentStore. A special PSR-11 container ensures that all other services are mocked. Let's see it in action. The annotated integration test should be self explanatory.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Integration; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\ServiceBus\\UiExchange; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Messaging\\Message; final class NotifySecurityTest extends BaseTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp() { \/\/The BaseTestCase loads all Event Machine descriptions configured in config\/autoload\/global.php parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke(Message $event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage(): Message { return $this-&gt;lastReceivedMessage; } }; } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { $this-&gt;eventMachine-&gt;bootstrapInTestMode( \/\/Add history events that should have been recorded before current test scenario [ $this-&gt;message(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ], \/\/Provide mocked services used in current test scenario, if you forget one the test will throw an exception \/\/You don't have to mock the event store and document store, that is done internally [ \/\/Remember, UiExchange is our process manager that pushes events to rabbit \/\/Event Machine is configured to push DoubleCheckInDetected events on to UiExchange (src\/Api\/Listener.php) UiExchange::class =&gt; $this-&gt;uiExchange ] ); \/\/Try to check in John twice $checkInJohn = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventMachine-&gt;dispatch($checkInJohn); \/\/After dispatch $this-&gt;lastPublishedEvent points to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals(Event::DOUBLE_CHECK_IN_DETECTED, $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;messageName()); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;payload()); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/event_machine\/set_up.html#3-1-1","title":"Set Up","content":"tbd"}]